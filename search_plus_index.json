{"./":{"url":"./","title":"前言","keywords":"","body":"个人介绍 个人站点 个人golang学习仓库 友情连接 书栈网 李文周的博客 刘江的博客教程 Zhang_derek pyqt5代码示例 白月黑羽 DragonFire 菜鸟教程 波晓张 听雨危楼 终身编程者 maple-shaw Mr.Seven 武沛齐 pyyu Eva-J 测试教程网 tianv5 CSDN博主tianv5 docker 快速入门 hellogithub Road To Coding 项目常识 融RRPL 参考文档 python标准库 golang标准库 gunicorn文档 C语言参考手册 C++参考手册 learn golang with test numpy练习册 Rust语言圣经 Shell编程范例 k8s入门教程 K8s PaaS/DevOps Rust 系统编程入门 flutter豆瓣样例 -- -- 备用github Kubernetes 基础教程 "},"blog/python/ubuntu_clang_python.html":{"url":"blog/python/ubuntu_clang_python.html","title":"ubuntu环境下C语言拓展cpython","keywords":"","body":"ubuntu环境下用C语言来拓展python3示例 安装python3-devel sudo apt -y install python38-devel 配置C语言includepath环境变量 在 bashrc 或 bash_profile中添加环境变量，并使之生效 编写C代码，新建文件 spammoudle.c #define PY_SSIZE_T_CLEAN #include #include static PyObject * spam_system(PyObject *self, PyObject *args) { const char *command; int sts; if (!PyArg_ParseTuple(args, \"s\", &command)) return NULL; sts = system(command); return PyLong_FromLong(sts); } static PyObject *SpamError; static PyMethodDef SpamMethods[] = { {\"system\", spam_system, METH_VARARGS, \"Execute a shell command.\"}, {NULL, NULL, 0, NULL} /* Sentinel */ }; static struct PyModuleDef spammodule = { PyModuleDef_HEAD_INIT, \"spam\", /* name of module */ \"test module C\", /* module documentation, may be NULL */ -1, /* size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */ SpamMethods }; PyMODINIT_FUNC PyInit_spam(void) { PyObject *m; m = PyModule_Create(&spammodule); if (m == NULL) return NULL; SpamError = PyErr_NewException(\"spam.error\", NULL, NULL); Py_XINCREF(SpamError); if (PyModule_AddObject(m, \"error\", SpamError) 在模块目录下编写setup.py from distutils.core import setup, Extension spam = Extension('spam', sources = ['spammodule.c']) setup (name = 'spam', version = '1.0', description = 'This is a demo package', ext_modules = [spam]) 安装编写的模块 python setup.py install 测试使用编写的模块 (venv) wangchenxi@lenovo:/var/history$ python Python 3.8.10 (default, Nov 26 2021, 20:14:08) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import spam >>> spam.system('ls -l ') 总用量 68 -rw------- 1 wangchenxi wangchenxi 151 12月 6 18:40 wangchenxi-1000-2021-12-06.log -rw------- 1 wangchenxi wangchenxi 341 12月 7 19:02 wangchenxi-1000-2021-12-07.log -rw------- 1 wangchenxi wangchenxi 117 12月 11 02:38 wangchenxi-1000-2021-12-11.log -rw------- 1 wangchenxi wangchenxi 404 12月 13 23:18 wangchenxi-1000-2021-12-13.log -rw------- 1 wangchenxi wangchenxi 971 12月 16 23:35 wangchenxi-1000-2021-12-16.log -rw------- 1 wangchenxi wangchenxi 94 12月 17 00:22 wangchenxi-1000-2021-12-17.log -rw------- 1 wangchenxi wangchenxi 1449 12月 18 23:56 wangchenxi-1000-2021-12-18.log -rw------- 1 wangchenxi wangchenxi 651 12月 19 15:05 wangchenxi-1000-2021-12-19.log -rw------- 1 wangchenxi wangchenxi 801 12月 20 00:52 wangchenxi-1000-2021-12-20.log -rw------- 1 wangchenxi wangchenxi 98 1月 2 02:09 wangchenxi-1000-2022-01-02.log -rw------- 1 wangchenxi wangchenxi 5949 1月 15 16:04 wangchenxi-1000-2022-01-08.log -rw------- 1 wangchenxi wangchenxi 14882 1月 16 21:39 wangchenxi-1000-2022-01-16.log -rw------- 1 wangchenxi wangchenxi 1274 1月 17 22:19 wangchenxi-1000-2022-01-17.log 0 >>> 结语 写这篇文档的目的，是为了把流程走通，具体的细节部分，留待后续仔细探究发现。 "},"blog/python/tkinter_gui_demo.html":{"url":"blog/python/tkinter_gui_demo.html","title":"tkinter开发界面客户端工具","keywords":"","body":"tkinter开发界面客户端工具 前言 这是一个使用python3开发的windows环境下，读取串口数据的桌面小工具。 要求 跨系统（windowsXP、Windows7及以上系统均可运行） 短时间 读取串口 界面能展示，且支持另存Excel 国际化（界面支持中文、英文） 结论 python3有现成的第三方库，灵活方便，以上功能要求都能满足。 最后使用pyinstaller发布。 同时具备完备的日志记录和分析功能。 涉及Excel写、日志、用户剪切板操作、COM串口读写、GUI界面开发、发布等。 源码 #! /usr/bin/python3 # coding:utf-8 import os import time import tkinter as tk from tkinter import ttk from sys import exit from tkinter import Menu from tkinter import filedialog import logging from logging import handlers import traceback import xlwt import serial from tkinter import messagebox import binascii class I18N(): '''Internationalization''' def __init__(self, language): if language == 'chi': self.resourceLagChi() elif language == 'eng': self.resourceLagEng() def resourceLagChi(self): self.lab_chi = '中文' self.lab_eng = '英文' self.lab_trans = '切换语言' self.lab_quit = '退出' self.lab_start = '开始' self.lab_com = 'COM标识' self.lab_baud = '波特率' self.lab_timeout = '超时（秒）' self.btn_test_read = '测试读数' self.btn_test_read_remark = '添加备注' self.btn_read = '读取数据' self.btn_copy = '复制最近10条数据' self.app_title = \"水分测量\" self.port_seting_title = \"串口设置\" self.data_read_title = \"读取数据\" self.data_record_title = \"数据记录\" self.data_record_label = \"历史记录\" self.save_to_excel = \"将记录写入excel文件\" self.excel_header_list=[\"时间\",\"样品序号\",\"样品代号\",\"温度\",\"重量\",\"水分\",\"电压\",\"测量次数\",\"平均标识\", \"备注\"] self.com_formate_error=\"COM接口标识格式不正确\" self.baud_formate_error=\"波特率格式不正确\" self.timeout_formate_error=\"超时设置不正确\" self.warn=\"提示\" self.messages=[\"读取成功\",\"没有串口未识别，请调整串口标识\",\"串口读取异常，调整超时和波特率配置\", \"数据解析异常，联系开发人员\", \"数据展示异常，联系开发人员\"] def resourceLagEng(self): self.lab_chi = 'Chinese' self.lab_eng = 'English' self.lab_trans = 'Change Language' self.lab_quit = 'Quit' self.lab_start = 'Start' self.lab_com = 'COM ID' self.lab_baud = 'Baud rate' self.lab_timeout = 'Timeout (seconds)' self.btn_test_read = 'Test reading COM' self.btn_read = 'Reading Data' self.btn_copy = 'Copy the last 10 data' self.app_title = \"Moisture measurement\" self.port_seting_title = \"Serial port setting\" self.data_read_title = \"Get Data\" self.data_record_title = \"Data records\" self.data_record_label = \"History records\" self.save_to_excel = \"Write records to excel file\" self.btn_test_read_remark = 'Remarks reading data' self.excel_header_list=[\"time\", \"sample number\", \"sample code\", \"temperature\", \"weight\", \"moisture\", \"voltage\", \"measurement times\", \"average identification\", \"remark\"] self.com_formate_error=\"The COM interface ID format is incorrect\" self.baud_formate_error=\"The baud rate format is incorrect\" self.timeout_formate_error=\"The timeout setting is incorrect\" self.warn=\"Warnning\" self.messages=[ \"Read successfully\", \"No serial port is not recognized, please adjust the serial port ID\", \"Serial port read timeout, adjust timeout or baudrate configuration\", \"Data resolution exception, contact developer\", \"Data display exception, contact developer\"] def get_app_log_handler(name): applog = logging.getLogger(name) rh = handlers.RotatingFileHandler( f'{name}.log', maxBytes=1024*1024*100, backupCount=5) dfs = '%Y-%m-%d %H:%M:%S %p' fs = '%(asctime)s | %(levelname)s|pathname: %(pathname)s|module: %(module)s|funcName: %(funcName)s|lineno: %(lineno)d|pid: %(process)d|tid: %(thread)d|msg: %(message)s' app_format = logging.Formatter(fs, dfs) rh.setFormatter(app_format) applog.addHandler(rh) applog.setLevel(logging.DEBUG) return applog applog = get_app_log_handler(\"app\") errorlog = get_app_log_handler(\"traceback\") excel_header_list = [] all_read_data = list() serial_name=\"COM1\" serial_baud_rate=2400 serial_timeout=5 onece_read_len=60 default_len=10 def format_data_raw(): s=\"3D 08 38 02 00 05 01 05 00 01 05 08 06 08 05 01\" raw_data=\"\" for c in s.split(): cb=bin(int(c, 16))[2:].rjust(8, '0') raw_data=f\"{raw_data}0{cb}1\" dst=b\"\" for i in range(0,160,8): b=raw_data[i:i+8] b=hex(int(b, 2))[2:] b=b.rjust(2, '0') b=binascii.a2b_hex(b) dst+=b return dst def parse_bytes_data(b_data): try: time_str=time.asctime() sample_No=f\"{hex(int(b_data[11:19],2))[2:]}\" # 3D 08 sample_code=f\"{hex(int(b_data[21:29],2))[2:]}\" # 38 temperature=f\"{hex(int(b_data[31:39],2))[2:]}{hex(int(b_data[41:49],2))[2:]}.{hex(int(b_data[51:59],2))[2:]}\" # 02 00 05 weight=f\"{hex(int(b_data[61:69],2))[2:]}{hex(int(b_data[71:79],2))[2:]}{hex(int(b_data[81:89],2))[2:]}\" # 01 05 00 moisture=f\"{hex(int(b_data[91:99],2))[2:]}{hex(int(b_data[101:109],2))[2:]}.{hex(int(b_data[111:119],2))[2:]}%\" # 01 05 08 # 3D 08 38 02 00 05 01 05 00 01 05 08 06 08 05 01 voltage=f\"{hex(int(b_data[121:129],2))[2:]}.{hex(int(b_data[131:139],2))[2:]}\" # 06 08 measurement_times=f\"{hex(int(b_data[141:149],2))[2:]}\" # 05 avg_flag=f\"{hex(int(b_data[151:159],2))[2:]}\" # 01 return [ time_str, sample_No, sample_code, temperature, weight, moisture, voltage, measurement_times, avg_flag] except Exception as e: errorlog.error(f\"parse data error: {e}\") errorlog.error(traceback.format_exc()) def save_to_excel_action(filenewpath): try: applog.info(f\"ready to write excel {filenewpath}\") # 创建新的workbook（其实就是创建新的excel） workbook = xlwt.Workbook(encoding= 'utf-8') # 创建新的sheet表 worksheet = workbook.add_sheet(\"My new Sheet\") st_rn=0 st_cn=0 row_cn=st_cn for h in excel_header_list: worksheet.write(st_rn, row_cn, h) row_cn += 1 applog.info(f\"write excel header successfully\") for line in all_read_data: st_rn +=1 row_cn=st_cn for d in line: worksheet.write(st_rn, row_cn, d) row_cn+=1 # 保存 workbook.save(filenewpath) applog.info(f\"write excel data successfully\") except Exception as e: errorlog.error(f\"save_to_excel_action error: {e}\") errorlog.error(traceback.format_exc()) def save_excel(): try: filetypes = [(\"MincroSoft Excel XLS\", \"*.xls\")] # 返回一个 pathname 文件路径字符串，如果取消或者关闭则返回空字符， # 返回文件如何操作是后续代码的事情， # 该函数知识返回选择文件的文件名字，不具备保存文件的能力 filenewpath = filedialog.asksaveasfilename( title='保存文件', filetypes=filetypes, defaultextension='.xls', initialdir=os.getenv('homepath') or os.getenv('home')) applog.info(f\"save execl file:{filenewpath} need Action\") save_to_excel_action(filenewpath) except Exception as e: errorlog.error(f\"save_excel error: {e}\") errorlog.error(traceback.format_exc()) class OOP: \"\"\" 主操作界面 \"\"\" def __init__(self) -> None: self.win = tk.Tk() self.win.resizable(0, 0) self.i18n = I18N('eng') global excel_header_list excel_header_list=self.i18n.excel_header_list self._create_widget() def _quit(self): self.win.quit() self.win.destroy() exit() def _chi(self): self.win.destroy() self.win = tk.Tk() self.win.resizable(0, 0) self.i18n = I18N('chi') global excel_header_list excel_header_list=self.i18n.excel_header_list self._create_widget() def _eng(self): self.win.destroy() self.win = tk.Tk() self.win.resizable(0, 0) self.i18n = I18N('eng') global excel_header_list excel_header_list=self.i18n.excel_header_list self._create_widget() # 创建验证函数 def check_com(self): com=self.com_entry.get() if com.startswith(\"COM\") or com.startswith('com'): num= com.strip(\"comCOM\") if num.isdigit():return messagebox.showwarning( title=self.i18n.warn, message=self.i18n.com_formate_error) self.com_entry.delete(0,tk.END) self.com_entry.insert(\"end\", serial_name) return False def check_baud(self): global serial_baud_rate baud_rate=self.baud_entry.get() if baud_rate and baud_rate.isdigit(): serial_baud_rate=baud_rate return messagebox.showwarning( title=self.i18n.warn, message=self.i18n.baud_formate_error) self.baud_entry.delete(0,tk.END) self.baud_entry.insert(\"end\", serial_baud_rate) return False def check_timeout(self): global serial_timeout timeout=self.timeout_entry.get() if timeout and timeout.isdigit(): serial_timeout=timeout return True messagebox.showwarning( title=self.i18n.warn, message=self.i18n.timeout_formate_error) self.timeout_entry.delete(0,tk.END) self.timeout_entry.insert(\"end\", serial_timeout) return False def _trans(self): pass def show_data(self): self.test_read_content.delete(*self.test_read_content.get_children()) st = 0 for item in all_read_data[-1::-1]: self.test_read_content.insert(\"\", st, text=f\"{len(all_read_data) - st}\", values=item) st +=1 def _read_bin_str(self, ser): bin_str_list=[] max_read_times=3 while max_read_times: b_data=ser.read(20) applog.info(f\"data: {binascii.b2a_hex(b_data)}\") for b in b_data: s=bin(b)[2:] s=s.rjust(8, '0') bin_str_list.append(s) self.bin_str+=\"\".join(bin_str_list) start_index=self.bin_str.find('0001111011') if start_index != -1 and start_index+160 "},"blog/python/标准库之itertools.html":{"url":"blog/python/标准库之itertools.html","title":"标准库之itertools","keywords":"","body":"标准库之itertools itertools 是 Python 的标准库之一，它提供了用于生成排列、组合、笛卡尔积等迭代器的函数。 以下是一些使用 itertools 进行排列组合操作的例子： 排列 from itertools import permutations items = [1, 2, 3] for p in permutations(items): print(p) 组合 from itertools import combinations items = [1, 2, 3] for c in combinations(items, 2): # 2 表示要选择的元素数量 print(c) 笛卡尔积（Cartesian Product） from itertools import product items = [1, 2, 3] for p in product(items, repeat=2): # repeat=2 表示重复的次数 print(p) 组合带重复（Combinations with Replacement） from itertools import combinations_with_replacement items = [1, 2, 3] for c in combinations_with_replacement(items, 2): print(c) 这些函数返回的是迭代器，可以用来生成所有可能的排列或组合，而不需要预先计算和存储所有的结果， 这样可以节省内存并提高效率。如果你需要将这些迭代器转换为列表，可以使用 list() 函数。 "},"blog/python/gunicornServerHook.html":{"url":"blog/python/gunicornServerHook.html","title":"gunicorn server hook 说明","keywords":"","body":"gunicorn server hook 说明 Server Hooks on_starting Default: def on_starting(server): pass Called just before the master process is initialized. The callable needs to accept a single instance variable for the Arbiter. on_reload Default: def on_reload(server): pass Called to recycle workers during a reload via SIGHUP. The callable needs to accept a single instance variable for the Arbiter. when_ready Default: def when_ready(server): pass Called just after the server is started. The callable needs to accept a single instance variable for the Arbiter. pre_fork Default: def pre_fork(server, worker): pass Called just before a worker is forked. The callable needs to accept two instance variables for the Arbiter and new Worker. post_fork Default: def post_fork(server, worker): pass Called just after a worker has been forked. The callable needs to accept two instance variables for the Arbiter and new Worker. post_worker_init Default: def post_worker_init(worker): pass Called just after a worker has initialized the application. The callable needs to accept one instance variable for the initialized Worker. worker_int Default: def worker_int(worker): pass Called just after a worker exited on SIGINT or SIGQUIT. The callable needs to accept one instance variable for the initialized Worker. worker_abort Default: def worker_abort(worker): pass Called when a worker received the SIGABRT signal. This call generally happens on timeout. The callable needs to accept one instance variable for the initialized Worker. pre_exec Default: def pre_exec(server): pass Called just before a new master process is forked. The callable needs to accept a single instance variable for the Arbiter. pre_request Default: def pre_request(worker, req): worker.log.debug(\"%s %s\" % (req.method, req.path)) Called just before a worker processes the request. The callable needs to accept two instance variables for the Worker and the Request. post_request Default: def post_request(worker, req, environ, resp): pass Called after a worker processes the request. The callable needs to accept two instance variables for the Worker and the Request. child_exit Default: def child_exit(server, worker): pass Called just after a worker has been exited, in the master process. The callable needs to accept two instance variables for the Arbiter and the just-exited Worker. New in version 19.7. worker_exit Default: def worker_exit(server, worker): pass Called just after a worker has been exited, in the worker process. The callable needs to accept two instance variables for the Arbiter and the just-exited Worker. nworkers_changed Default: def nworkers_changed(server, new_value, old_value): pass Called just after num_workers has been changed. The callable needs to accept an instance variable of the Arbiter and two integers of number of workers after and before change. If the number of workers is set for the first time, old_value would be None. on_exit Default: def on_exit(server): pass Called just before exiting Gunicorn. The callable needs to accept a single instance variable for the Arbiter. "},"blog/python/pythonLinuxIpcMessageQueue.html":{"url":"blog/python/pythonLinuxIpcMessageQueue.html","title":"python Linux ipc通信之消息队列实例","keywords":"","body":"python Linux ipc通信之消息队列实例 消费端 import posix_ipc import selectors # This program uses `posix_ipc` together with the `selectors`library from the # Python standard library. `selectors` provides \"high-level I/O multiplexing\" akin to having an event library. # The message queue is created as usual mq = posix_ipc.MessageQueue(\"/python_ipc_test\", flags=posix_ipc.O_CREAT, max_messages=1024, max_message_size=1024 * 1024) mq.block = False # Function is defined to handle events on the queue counter = 0 def accept(message_queue, mask): global counter (msg, prio) = message_queue.receive() counter += 1 print(f\" \\r{len(msg)}, Priority:{prio},{counter}\", end=\"\") # print(\"Message: \", msg) # print(\"Priority: \", prio) # The selector can now be created... sel = selectors.DefaultSelector() # ... and the message queue is registered. Other event sources could also be # registered simultaneously, but for now we stick to the queue sel.register(mq, selectors.EVENT_READ, accept) # `.select()` will block until an event is triggered while True: try: events = sel.select() for key, mask in events: # `.data` contains the third argument from `.register` above -- we use it for the callback. callback = key.data callback(key.fileobj, mask) except Exception as e: import traceback print(traceback.format_exc()) break finally: \"\" # With the message successfully received, we can unlink and close. mq.unlink() mq.close() 生产端 import time import traceback import posix_ipc # This program opens the message queue and sends a message mq = posix_ipc.MessageQueue(\"/python_ipc_test\") mq.block = True counter = 0 s_time = time.time() for i in range(500000): try: mq.send(\"1\" * 1024*5) counter += 1 print(f'\\r send counter:{counter}', end=\"\") except Exception as e: print(traceback.format_exc()) finally: \"\" print(\"\") print(f\"use time: {time.time() - s_time}\") "},"blog/python/pythonGeventDemo.html":{"url":"blog/python/pythonGeventDemo.html","title":"python gevent 使用实例","keywords":"","body":"python gevent 使用实例 from gevent import spawn,joinall,monkey;monkey.patch_all() import time def task(pid): \"\"\" Some non-deterministic task \"\"\" time.sleep(2) print('Task %s done' % pid) def synchronous(): for i in range(3): task(i) def asynchronous(): g_l=[spawn(task,i) for i in range(3)] joinall(g_l) if __name__ == '__main__': print('Synchronous:') synchronous() print('Asynchronous:') asynchronous() "},"blog/python/python_sysv-ipc_Demo.html":{"url":"blog/python/python_sysv-ipc_Demo.html","title":"sysv-ipc 进程间通信的使用","keywords":"","body":"python sysv-ipc 进程间通信的使用 配置系统参数 打开系统配置添加如下配置 sudo vim /etc/sysctl.conf kernel.msgmax=1048576 kernel.msgmnb=1048576 系统参数生效 执行如下命令使修改生效 sudo sysctl -p 系统参数生效确认 执行如下命令查看是否生效 ipcs -l 显示如下，则生效： ---------- 消息限制 ----------- 系统最大队列数量 = 32000 最大消息尺寸 (字节) = 1048576 默认的队列最大尺寸 (字节) = 1048576 ---------- 同享内存限制 ------------ 最大段数 = 4096 最大段大小 (千字节) = 18014398509465599 最大总共享内存 (千字节) = 18014398509481980 最小段大小 (字节) = 1 --------- 信号量限制 ----------- 最大数组数量 = 32000 每个数组的最大信号量数目 = 32000 系统最大信号量数 = 1024000000 每次信号量调用最大操作数 = 500 信号量最大值=32767 消费端代码 import sysv_ipc mq_id = sysv_ipc.ftok(\"/tmp\", 1) try: mq = sysv_ipc.MessageQueue(mq_id) except sysv_ipc.ExistentialError: print('''Message queue with key \"{}\" doesn't exist.'''.format(mq_id)) else: mq.remove() print('Message queue with key \"{}\" removed'.format(mq_id)) mq = sysv_ipc.MessageQueue(mq_id, sysv_ipc.IPC_CREX, max_message_size=1024*1024) # Function is defined to handle events on the queue counter = 0 while True: try: s, _ = mq.receive() counter += 1 print(f\" \\r{len(s)}, Priority:{_},{counter}\", end=\"\") except Exception as e: import traceback print(traceback.format_exc()) break finally: \"\" # With the message successfully received, we can unlink and close. mq.remove() 生产者 import time import traceback import sysv_ipc mq_id = sysv_ipc.ftok(\"/tmp\", 1) mq = sysv_ipc.MessageQueue(mq_id, max_message_size=1024*1024) # mq.block = True counter = 0 tmp_str = \"1\" * 1024*1000 s_time = time.time() for i in range(500000): try: mq.send(tmp_str) counter += 1 print(f'\\r send counter:{counter}', end=\"\") except Exception as e: print(traceback.format_exc()) finally: \"\" print(\"\") print(f\"use time: {time.time() - s_time}\") "},"blog/python/flask_test_moc.html":{"url":"blog/python/flask_test_moc.html","title":"flask实现一个moc服务","keywords":"","body":"使用flask实现一个测试桩 项目路径 testNode/ ├── main.py ├── test_node.conf.json ├── tn_commands.py └── tn_conf.py 配置文件 test_node.conf.json { \"host\": \"127.0.0.1\", \"port\": \"13499\", \"routers\": [ { \"service\": \"service_name\", \"route\": { \"args\": [ \"/test\" ], \"kwargs\": { \"methods\": [ \"GET\", \"POST\" ], \"endpoint\": \"endpoint\" } }, \"response\": { \"headers\": {}, \"body\": { \"date_from\": \"eval\", \"args\": [\"'hello test.'\"], \"kwargs\": {} } } } ] } tn_conf.py import json test_node_obj = None def get_conf_obj(): global test_node_obj if test_node_obj: return test_node_obj with open('./test_node.conf.json', 'r') as fd: test_node_obj = json.load(fd) test_node_obj = type(\"tn\", (object,), test_node_obj) return test_node_obj main.py from flask import Flask from tn_conf import get_conf_obj app = Flask(__name__) conf_obj = get_conf_obj() file_content = '''#! /user/bin/python # -*- coding:utf-8 -*- from flask import Blueprint, request import tn_commands user_bp = Blueprint(\"蓝图标识\", __name__, url_prefix='/') \\n''' for route in conf_obj.routers: args = route[\"route\"][\"args\"] kwargs = route[\"route\"][\"kwargs\"] func = route[\"response\"][\"body\"][\"date_from\"] func_args = route[\"response\"][\"body\"][\"args\"] func_kwargs = route[\"response\"][\"body\"][\"kwargs\"] file_content = f'''{file_content} @user_bp.route(*{args}, **{kwargs}) def {route[\"service\"]}(): return {func}(*{func_args}, **{func_kwargs}) \\n\\n''' with open(\"all_route.py\", \"w\", encoding=\"utf-8\") as fd: fd.write(file_content) from all_route import user_bp app.register_blueprint(user_bp) if __name__ == '__main__': app.run(conf_obj.host, conf_obj.port) tn_commands.py from flask import request def from_file(file, encoding='utf-8'): with open(file, mode='r', encoding=encoding) as fd: return fd.read() "},"blog/python/python_py_spy.html":{"url":"blog/python/python_py_spy.html","title":"python性能分析之py-spy","keywords":"","body":" python性能分析工具py-spy 前言 用 top 的方式分析 Python 程序性能的工具。一款 Python 程序性能分析工具，它可以让你在不重启程序或修改代码的情况，直观地看到 Python 程序中每个函数花费的时间。 安装 # 安装 pip install py-spy # record 命令将配置文件记录到文件中，可用来生成火焰图 py-spy record -o profile.svg --pid 进程ID # top 命令实时展示函数花费时间 py-spy top --pid 进程ID # dump 命令显示每个 Python 线程的当前调用堆栈 py-spy dump --pid 进程ID 命令行示例 了解更多 对应项目的github "},"blog/python/一个ip地址合并的样例.html":{"url":"blog/python/一个ip地址合并的样例.html","title":"ip地址合并的问题","keywords":"","body":"一个ip地址合并的样例 具体使用参考源码 #!/usr/bin/python3 # -*- coding:utf-8 -*- import IPy import ipaddress import logging import traceback logger = logging.getLogger() trace_logger = logging.getLogger() def merge_range_net(nets: list): out_nets = list() length = len(nets) if length == 0: return out_nets i = 0 while i net1[1]: continue # 重叠merge nets[ii] = None nets[i] = [min(net[0], net1[0]), max(net[1], net1[1])] re_loop = True break if re_loop: i = 0 else: i += 1 for net in nets: if net: first_ip = ipaddress.IPv4Address(net[0]) last_ip = ipaddress.IPv4Address(net[1]) out_nets.extend(ipaddress.summarize_address_range(first_ip, last_ip)) return out_nets def transfer2range(ip_desc : str): if \"range\" in ip_desc: res = ip_desc.split() try: res[1] = IPy.IP(res[1]).int() res[2] = IPy.IP(res[2]).int() return res[1:] except Exception as e: logger.error(f\"{e}\") trace_logger.error(traceback.format_exc()) return finally: \"\" net = None res = None try: if '/' in ip_desc: net = ipaddress.IPv4Network(ip_desc.split(\"/\")[0]) net = ipaddress.IPv4Network(ip_desc) except Exception as e: logger.error(f\"{e}\") trace_logger.error(traceback.format_exc()) if not net: return finally: \"\" try: return [IPy.IP(str(net.network_address)).int(), IPy.IP(str(net.broadcast_address)).int() ] except Exception as e: logger.error(f\"{e}\") trace_logger.error(traceback.format_exc()) return finally: \"\" def merge_ips(ip_desc: list): nets = list() for s in ip_desc: net = transfer2range(s) if net: nets.append(net) nets = merge_range_net(nets) return nets if __name__ == \"__main__\": try: ipdescs= ['1.1.1.1', '1.1.1.0', \"range 1.1.1.1 1.1.1.4\", '1.1.1.16/28', '1.1.1.20/31', '1.1.1.0/255.255.255.0'] print(merge_ips(ipdescs)) except Exception as e: print(traceback.format_exc()) "},"blog/python/pb生成pyi文件.html":{"url":"blog/python/pb生成pyi文件.html","title":"protocolbuffer源码pyi生成","keywords":"","body":"pb生成pyi文件 具体使用参考源码 import sys import re import os import jinja2 type2type ={ \"string\": \"str\", \"int32\" : \"int\", \"float\": \"float\", \"double\": \"float\", \"int64\": \"int\", \"uint32\": \"int\", \"uint64\": \"int\", \"sint32\": \"int\", \"sint64\": \"int\", \"fixed32\": \"int\", \"fixed64\": \"int\", \"sfixed32\": \"int\", \"sfixed64\": \"int\", \"bool\": \"bool\", \"bytes\": \"bytes\" } base_type_set = set(type2type.values()) already_class = set() imp_str = \"\"\"#!/usr/bin/python3 # -*- coding:utf-8 -*- import typing from google.protobuf.message import Message \"\"\" message_tmplate=''' class {{name}}(Message):{% for col in cols %} {{col.name}} {{col.typing}}{% endfor %} ''' class Field: def __init__(self, n=\"\", t=\"\") -> None: self.name :str = n self.typing :str = t @classmethod def parse_from_str(cls, field_str): fields = re.findall(r\"^\\s*(\\S+)\\s+(\\S+)\\s*=\\s*\\d+\\s*;\", field_str, flags=re.MULTILINE) for f in fields: t = type2type.get(f[0], f[0]) return cls(f[1], f\": {t}\") fields = re.findall(r\"^\\s*optional\\s+(\\S+)\\s+(\\S+)\\s*=\\s*\\d+\\s*;\", field_str, flags=re.MULTILINE) for f in fields: t = type2type.get(f[0], f[0]) return cls(f[1], f\": {t}\") fields = re.findall(r\"^\\s*repeated\\s+(\\S+)\\s+(\\S+)\\s*=\\s*\\d+\\s*;\", field_str, flags=re.MULTILINE) for f in fields: t = type2type.get(f[0], f[0]) return cls(f[1], f\": typing.List [{t}]\") fields = re.findall(r\"^\\s*map\\s*(\\S+)\\s*=\\s*\\d+\\s*;\", field_str, flags=re.MULTILINE) for f in fields: k = type2type.get(f[0], f[0]) v = type2type.get(f[1], f[1]) return cls(f[2], f\": typing.Dict[{k}, {v}]\") class Message: def __init__(self, n=\"\", f=list()) -> None: self.name : str = n self.fiels : list[Field] = f @classmethod def parse_from_str(cls, msg_str): name = re.findall(r\"\\s*message\\s+(\\S+)\\s+{.*?}\", msg_str, flags=re.DOTALL) if name: name = name[0] fields = list() results = re.findall(r\"^\\s*\\S+.*?\\s*=\\s*\\d+\\s*;\", msg_str, flags=re.MULTILINE) for result in results: fields.append(Field.parse_from_str(result)) return cls(name, fields) def code_render(self): template = jinja2.Template(message_tmplate) return template.render(name=self.name, cols=self.fiels) class Proto: def __init__(self, n: str = \"\", m: list = list()) -> None: self.imp :str = imp_str self.name :str = n self.messages :list[Message] = m @classmethod def parse_from_file(cls, name, *args, **kwargs): proto_file = f\"{name}.proto\" if not os.path.exists(proto_file): raise Exception(f\"{proto_file} not exist\") messages = list() with open(proto_file, mode=\"r\", encoding=\"utf-8\") as fd: proto_str = fd.read() msgs = re.findall(r\"\\s*(message\\s+(\\S+)\\s+{.*?})\", proto_str, flags=re.DOTALL) for msg in msgs: already_class.add(msg[1]) for msg in msgs: messages.append(Message.parse_from_str(msg[0])) return cls(name, messages) def render_to_file(self): texts = [self.imp,] for msg in self.messages: texts.append(msg.code_render()) with open(f\"{self.name}_pb2.pyi\", mode=\"w\", encoding=\"utf-8\") as fd: fd.write(\"\\n\".join(texts)) os.system(f\"protoc --python_out=. {self.name}.proto\") if __name__ == \"__main__\": proto = Proto.parse_from_file(*sys.argv[1:]) proto.render_to_file() "},"blog/scipy/pandas500demo.html":{"url":"blog/scipy/pandas500demo.html","title":"scipy数据分析demo源码","keywords":"","body":"pandas500demo 环境依赖 et-xmlfile==1.1.0 numpy==1.26.4 openpyxl==3.1.2 pandas==2.2.1 pyreadline==2.1 python-dateutil==2.9.0.post0 pytz==2024.1 six==1.16.0 tzdata==2024.1 001　使用随机数创建一个DataFrame import pandas as pd #导入pandas库，并使用pd重命名pandas import numpy as np #导入numpy库，并使用np重命名numpy from numpy import random #导入numpy库的随机数模块random #使用随机数创建带行标签和列名的DataFrame df=pd.DataFrame(random.randint(0,5000,size=(5,10)), index=['R0','R1','R2','R3','R4'], columns=['C0','C1','C2','C3','C4','C5','C6','C7','C8','C9']) ##使用随机数创建默认的带行标签和列名的DataFrame #df=pd.DataFrame(random.randint(0,5000,size=(5,10))) ##使用连续的整数创建带行标签和列名的DataFrame #df=pd.DataFrame(np.arange(50).reshape((5,10)), index=['R0','R1','R2','R3','R4'], columns=['C0','C1','C2','C3','C4','C5','C6','C7','C8','C9']) ##使用连续的整数创建默认的带行标签和列名的DataFrame #df=pd.DataFrame(np.arange(50).reshape((5,10))) df #输出df的所有数据 002　使用字母设置DataFrame的行标签 import pandas as pd #导入pandas库，并使用pd重命名pandas df=pd.read_excel('myexcel.xlsx') #读取 myexcel.xlsx文件的第1个工作表 df #输出 df 的所有数据 #将 df 的行标签调整为从1开始 #df.index=range(1,len(df)+1) #df.index=pd.Index([1,2,3]) #df.index+=1 #将 df 的行标签调整为字母A、B、C df.index=['A','B','C'] ##输出 df 的第1行数据 #df.loc['A':'A'] df #输出 df 在修改行标签之后的所有数据 003　使用日期设置DataFrame的行标签 import pandas as pd #导入pandas库，并使用pd重命名pandas #读取myexcel.xlsx文件的Sheet1工作表 df=pd.read_excel('myexcel.xlsx',sheet_name='Sheet1') df #输出df的所有数据 #将df的行标签调整为从2021-08-23到2021-08-27 df.index=pd.date_range('20210823',periods=5) #df.index=pd.date_range('20210823',periods=df.shape[0]) #df.index=pd.date_range(start='20210823',periods=5) #df.index=pd.date_range(end='20210827',periods=5) #将df的行标签调整为从2021-08-23到2021-09-04 #df.index=pd.date_range('20210823',periods=5,freq='3D') #将df的行标签调整为从2021-08-31到2022-04-30 #df.index=pd.date_range('20210831',periods=5,freq='2M') #将df的行标签调整为从2021-12-31到2029-12-31 #df.index=pd.date_range('20211231',periods=5,freq='2Y') #输出df的第一行数据 #df.loc['2021-08-23':'2021-08-23'] df #输出df在调整行标签之后的所有数据 004　使用月份设置DataFrame的行标签 股票代码,股票名称,收盘价,成交额,流通市值,总市值 300393,中来股份,15.51,12.91亿,141.6亿,168.5亿 603613,国联股份,118.08,5.56亿,262.3亿,406.1亿 300172,中电环保,5.34,2.31亿,36.20亿,36.20亿 300510,金冠股份,9.13,8.89亿,75.07亿,75.65亿 603938,三孚股份,69.08,7.17亿,134.8亿,134.8亿 import pandas as pd #导入pandas库，并使用pd重命名pandas #读取myexcel.xlsx文件的Sheet1工作表 df=pd.read_excel('myexcel.xlsx',sheet_name='Sheet1') df #输出的所有数据 #将df的行标签调整为从2021-01到2021-05 df.index=pd.period_range(start='2021-01',end='2021-05',freq='M') #df.index=pd.period_range('1/1/2021',freq='M',periods=5) #df.index=pd.PeriodIndex(pd.period_range(start='2021-01',end='2021-05',freq='M')) ##将df的行标签调整为从2017年到2021年 #df.index=pd.period_range(start='2017',end='2021',freq='Y') #df.index=pd.period_range('1/1/2017',freq='Y',periods=5) ##将df的行标签调整为从2021-08-09到2021-08-13 #df.index=pd.period_range('2021-08-09',freq='D',periods=5) ##将df的行标签调整为从2021-09-13 10:00:00到2021-09-13 10:20:00 #df.index=pd.period_range(start='2021-09-13 10:00:00',end='2021-09-13 10:20:00',freq='300S') ##按周(Week)调整df的行标签 #df.index=pd.period_range(start='2021-01-01',freq='W',periods=5) ##输出df的第4行数据 #df.loc['2021-04':'2021-04'] df #输出df在调整行标签之后的所有数据 日期,股票代码,股票名称,收盘价,成交额,流通市值,总市值 2021-01,300393,中来股份,15.51,12.91亿,141.6亿,168.5亿 2021-02,603613,国联股份,118.08,5.56亿,262.3亿,406.1亿 2021-03,300172,中电环保,5.34,2.31亿,36.20亿,36.20亿 2021-04,300510,金冠股份,9.13,8.89亿,75.07亿,75.65亿 2021-05,603938,三孚股份,69.08,7.17亿,134.8亿,134.8亿 005　使用月初日期设置DataFrame的行标签 ,盐水鸭,酱鸭,板鸭,烤鸭 0,1800,1600,2400,1200 1,2600,1800,2000,1800 2,2400,2100,5900,2480 3,2000,2800,1800,2400 4,2500,1200,2500,3900 import pandas as pd #导入pandas库，并使用pd重命名pandas #读取 myexcel.xlsx文件的 Sheet1工作表 df=pd.read_excel('myexcel.xlsx',sheet_name='Sheet1') df #输出 df 的所有数据 #将 df 的行标签调整为每月的月初日期 df.index=pd.date_range('20210111',periods=5,freq=pd.offsets.MonthBegin(1)) ##将 df 的行标签调整为每月的工作日月初日期 ##df.index=pd.date_range('20210111',periods=5, freq=pd.offsets.BusinessMonthBegin(1)) ##将 df 的行标签调整为每月的月末日期 ##df.index=pd.date_range(start='20210111',periods=5,freq='1M') ##df.index=pd.date_range('20210111',periods=5,freq=pd.offsets.MonthEnd(1)) ##将 df 的行标签调整为每月的工作日月末日期 ##df.index=pd.date_range('20210111',periods=5,freq=pd.offsets.BusinessMonthEnd(1)) ##将 df 的行标签调整为每季的季末日期 df.index=pd.date_range(start='20210111',periods=5,freq='1Q') ##df.index=pd.date_range('20210111',periods=5,freq=pd.offsets.QuarterEnd(1)) ##将 df 的行标签调整为每季的季初日期 ##df.index=pd.date_range('20210111',periods=5,freq=pd.offsets.QuarterBegin(1)) ##将 df 的行标签调整为每年的年末日期 df.index=pd.date_range(start='20210111',periods=5,freq='1Y') ##df.index=pd.date_range('20210111',periods=5,freq=pd.offsets.YearEnd(1)) ##将 df 的行标签调整为每年的年初日期 ##df.index=pd.date_range('20210111',periods=5,freq=pd.offsets.YearBegin(1)) df #输出 df 在调整行标签之后的所有数据 日期,盐水鸭,酱鸭,板鸭,烤鸭 2021-02-01,1800,1600,2400,1200 2021-03-01,2600,1800,2000,1800 2021-04-01,2400,2100,5900,2480 2021-05-01,2000,2800,1800,2400 2021-06-01,2500,1200,2500,3900 006　使用星期日设置DataFrame的行标签 日期,盐水鸭,酱鸭,板鸭,烤鸭 2021-02-07,1800,1600,2400,1200 2021-03-07,2600,1800,2000,1800 2021-04-04,2400,2100,5900,2480 2021-05-02,2000,2800,1800,2400 2021-06-06,2500,1200,2500,3900 import pandas as pd #导入pandas库，并使用pd重命名pandas #读取 myexcel.xlsx 文件的 Sheet1工作表 df=pd.read_excel('myexcel.xlsx',sheet_name='Sheet1',index_col=0) #输出 df 的所有数据 from pandas.tseries.offsets import WeekOfMonth #导入WeekOfMonth myList=[] for myday in df.index: #获取日期所在月份的第1个星期日 myList.append(myday+WeekOfMonth(weekday=6)) #获取日期所在月份的第2个星期日 myList.append(myday+pd.offsets.Week(weekday=6)) #获取日期所在月份的下个月的第1个星期日 myList.append((myday+pd.offsets.Week(weekday=6)*2)) #获取日期所在月份的下个月的第1个星期五 myList.append((myday+WeekOfMonth(weekday=6)*2)) #获取日期所在月份的第1个星期五 myList.append(myday+WeekOfMonth(weekday=4)) df.index=myList df #输出 df 在调整行标签之后的所有数据 007　使用月初日期设置DataFrame的行标签 006　使用月初日期设置DataFrame的行标签 006　使用月初日期设置DataFrame的行标签 "},"blog/golang/golang_env_build.html":{"url":"blog/golang/golang_env_build.html","title":"golang安装及一些常识","keywords":"","body":"Linux下安装 如果不是要在Linux平台敲go代码就不需要在Linux平台安装Go，我们开发机上写好的go代码只需要跨平台编译（详见文章末尾的跨平台编译）好之后就可以拷贝到Linux服务器上运行了，这也是go程序跨平台易部署的优势。 我们在版本选择页面选择并下载好go1.14.1.linux-amd64.tar.gz文件： wget https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz 将下载好的文件解压到/usr/local目录下： tar -zxvf go1.14.1.linux-amd64.tar.gz -C /usr/local # 解压 如果提示没有权限，加上sudo以root用户的身份再运行。执行完就可以在/usr/local/下看到go目录了。 配置环境变量： Linux下有两个文件可以配置环境变量，其中/etc/profile是对所有用户生效的；$HOME/.profile是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。 export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 修改/etc/profile后要重启生效，修改$HOME/.profile后使用source命令加载$HOME/.profile文件即可生效。 检查： ~ go version go version go1.14.1 linux/amd64 一些环境变量的说明 GOROOT和GOPATH都是环境变量，其中GOROOT是我们安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为GOPATH设置一个默认目录，并且在Go1.14及之后的版本中启用了Go Module模式之后，不一定非要将代码写到GOPATH目录下，所以也就不需要我们再自己配置GOPATH了，使用默认的即可。 GOPROXY 非常重要 Go1.14版本之后，都推荐使用go mod模式来管理依赖环境了，也不再强制我们把代码必须写在GOPATH下面的src目录了，你可以在你电脑的任意位置编写go代码。（网上有些教程适用于1.11版本之前。） 默认GoPROXY配置是：GOPROXY=https://proxy.golang.org,direct，由于国内访问不到https://proxy.golang.org，所以我们需要换一个PROXY，这里推荐使用https://goproxy.io或https://goproxy.cn。 可以执行下面的命令修改GOPROXY： go env -w GOPROXY=https://goproxy.cn,direct go run go run main.go也可以执行程序，该命令本质上也是先编译再执行。 go install go install表示安装的意思，它先编译源代码得到可执行文件，然后将可执行文件移动到GOPATH的bin目录下。因为我们的环境变量中配置了GOPATH下的bin目录，所以我们就可以在任意地方直接执行可执行文件了。 windows下编译Linux运行的可执行文件 如果我想在Windows下编译一个Linux下可执行文件，那需要怎么做呢？只需要在编译时指定目标操作系统的平台和处理器架构即可。 注意：无论你在Windows电脑上使用VsCode编辑器还是Goland编辑器，都要注意你使用的终端类型，因为不同的终端下命令不一样！！！目前的Windows通常默认使用的是PowerShell终端。 如果你的Windows使用的是cmd，那么按如下方式指定环境变量。 SET CGO_ENABLED=0 // 禁用CGO SET GOOS=linux // 目标平台是linux SET GOARCH=amd64 // 目标处理器架构是amd64 如果你的Windows使用的是PowerShell终端，那么设置环境变量的语法为 $ENV:CGO_ENABLED=0 $ENV:GOOS=\"linux\" $ENV:GOARCH=\"amd64\" 在你的Windows终端下执行完上述命令后，再执行下面的命令，得到的就是能够在Linux平台运行的可执行文件了。 go build Windows编译Mac可执行文件 Windows下编译Mac平台64位可执行程序： cmd终端下执行： SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build PowerShell终端下执行： $ENV:CGO_ENABLED=0 $ENV:GOOS=\"darwin\" $ENV:GOARCH=\"amd64\" go build "},"blog/golang/离线环境搭建GOPROXY.html":{"url":"blog/golang/离线环境搭建GOPROXY.html","title":"离线环境搭建GOPROXY","keywords":"","body":"离线环境搭建GOPROXY 下载go项目的依赖包 导出项目需要的go.mod文件，放到联通外网环境的机器上。 外网机器配置GOMODCACHE go env -w GOMODCACHE=\"C:\\your\\path\\pkg\\mod\" 在go.mod所在的文件夹下，执行 go mod download 这样go.mod里的依赖包将会下载到$GOMODCACHE下，打包$GOMODCACHE/cache/download文件夹，生成download.zip包。使用文件摆渡传到云桌面。 搭建内网环境文件服务 将download.zip文件导入服务器中，放到/export/package/go_download下。 登录服务器（例1.1.1.1），启动文件服务器 cd /export/package/go_download python3 -m http.server 8003 需要下载go依赖包的项目设置GOPROXY=http://1.1.1.1:8010 go env -w GOPROXY=http://1.1.1.1:8010 开始下载go依赖包 go mod tidy "},"blog/golang/fmt_placeholder.html":{"url":"blog/golang/fmt_placeholder.html","title":"golangfmt占位符号","keywords":"","body":"golang fmt格式“占位符” golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。 # 定义示例类型和变量 type Human struct { Name string } var people = Human{Name:\"zhangsan\"} 普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式。 Printf(\"%v\", people) {zhangsan}， %+v 打印结构体时，会添加字段名 Printf(\"%+v\", people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(\"#v\", people) main.Human{Name:\"zhangsan\"} %T 相应值的类型的Go语法表示 Printf(\"%T\", people) main.Human %% 字面上的百分号，并非值的占位符 Printf(\"%%\") % 布尔占位符 占位符 说明 举例 输出 %t true 或 false。 Printf(\"%t\", true) true 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(\"%b\", 5) 101 %c 相应Unicode码点所表示的字符 Printf(\"%c\", 0x4E2D) 中 %d 十进制表示 Printf(\"%d\", 0x12) 18 %o 八进制表示 Printf(\"%d\", 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(\"%q\", 0x4E2D) '中' %x 十六进制表示，字母形式为小写 a-f Printf(\"%x\", 13) d %X 十六进制表示，字母形式为大写 A-F Printf(\"%x\", 13) D %U Unicode格式：U+1234，等同于 \"U+%04X\" Printf(\"%U\", 0x4E2D) U+4E2D 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %b 无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat 的 'b' 转换格式一致。例如 -123456p-78 %e 科学计数法，例如 -1234.456e+78 Printf(\"%e\", 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(\"%e\", 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(\"%f\", 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\"%g\", 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\"%G\", 10.20+2i) (10.2+2i) 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(\"%s\", []byte(\"Go语言\")) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(\"%q\", \"Go语言\") \"Go语言\" %x 十六进制，小写字母，每字节两个字符 Printf(\"%x\", \"golang\") 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(\"%X\", \"golang\") 676F6C616E67 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(\"%p\", &people) 0x4f57f0 其它标记 占位符 说明 举例 输出 + 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 Printf(\"%+q\", \"中文\") \"\\u4e2d\\u6587\" - 在右侧而非左侧填充空格（左对齐该区域） # 备用格式：为八进制添加前导 0（%#o） Printf(\"%#U\", '中') U+4E2D 为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x； 如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串； 如果是可打印字符，%U（%#U）会写出该字符的 Unicode 编码形式（如字符 x 会被打印成 U+0078 'x'）。 ' ' (空格)为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开 0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 golang没有 '%u' 点位符，若整数为无符号类型，默认就会被打印成无符号的。 宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。 操作数的类型为int时，宽度与精度都可用字符 '*' 表示。 对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。 %e 和 %f 的默认精度为6 对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。 而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。 "},"blog/golang/golang100mistakes.html":{"url":"blog/golang/golang100mistakes.html","title":"100-go-mistakes","keywords":"","body":"golang100mistakes 2.2 100 个 Go 常见错误：100-go-mistakes 本周 star 增长数：550+，主语言：Go 如何避免这 100 个常见的 Go 使用错误呢？100-go-mistakes 收录了具体的错误场景和最佳实践。 GitHub 地址→https://github.com/teivah/100-go-mistakes "},"blog/golang/zap_userdefine.html":{"url":"blog/golang/zap_userdefine.html","title":"golang自定义日志样式","keywords":"","body":"golang zap 自定义日志格式 目录结构 test_zap ├── go.mod ├── go.sum ├── log_mgr │ ├── user_buffer.go │ ├── user_encoder.go │ ├── user_json_encoder.go │ ├── user_mem_encoder.go │ └── usr_define_logger.go ├── main.go ├── test.log └── test_zap main.go package main import ( \"test_zap/log_mgr\" \"go.uber.org/zap\" ) func main() { log := log_mgr.GetLogger() zap_field := new(zap.Field) zap_field.Interface = map[string]string{ \"traceId\": \"123ewerfaskkljdasflkndsflkdflkasl\", } log.Info(\"this is info message with fileds\", *zap_field) log.Info(\"this is info message with fileds\", zap.String(\"traceId\", \"111111111\")) log.Info(\"this is info message with fileds\", zap.String(\"traceId\", \"111111111\")) log.Info(\"this is info message with fileds\", zap.String(\"traceId\", \"111111111\")) log.Info(\"this is info message with fileds\", zap.String(\"traceId\", \"111111111\")) // 我的诉求 // 定义日志表示符号 // 日志分割 } usr_define_logger.go package log_mgr import ( \"fmt\" \"os\" \"time\" \"go.uber.org/zap\" \"go.uber.org/zap/buffer\" \"go.uber.org/zap/zapcore\" ) func FieldsTransfer2Map(fields []zapcore.Field) map[string]string { resMap := make(map[string]string, len(fields)) for _, v := range fields { resMap[v.Key] = v.String } return resMap } func (c consoleEncoder) EncodeEntry(ent zapcore.Entry, fields []zapcore.Field) (*buffer.Buffer, error) { line := UserGet() // We don't want the entry's metadata to be quoted and escaped (if it's // encoded as strings), which means that we can't use the JSON encoder. The // simplest option is to use the memory encoder and fmt.Fprint. // // If this ever becomes a performance bottleneck, we can implement // ArrayEncoder for our plain-text format. arr := getSliceEncoder() res := FieldsTransfer2Map(fields) if traceId, ok := res[\"traceId\"]; ok { usr_str := fmt.Sprintf(\"%s|\", traceId) line.AppendString(usr_str) } // 时间 if c.TimeKey != \"\" && c.EncodeTime != nil { c.EncodeTime(ent.Time, arr) } // 日志级别标识 if c.LevelKey != \"\" && c.EncodeLevel != nil { c.EncodeLevel(ent.Level, arr) } // 日志名称 if ent.LoggerName != \"\" && c.NameKey != \"\" { nameEncoder := c.EncodeName if nameEncoder == nil { // Fall back to FullNameEncoder for backward compatibility. nameEncoder = zapcore.FullNameEncoder } nameEncoder(ent.LoggerName, arr) } // 调用位置信息 if ent.Caller.Defined { if c.CallerKey != \"\" && c.EncodeCaller != nil { c.EncodeCaller(ent.Caller, arr) } if c.FunctionKey != \"\" { arr.AppendString(ent.Caller.Function) } } for i := range arr.elems { if i > 0 { line.AppendString(c.ConsoleSeparator) } fmt.Fprint(line, arr.elems[i]) } putSliceEncoder(arr) // Add the message itself. if c.MessageKey != \"\" { c.addSeparatorIfNecessary(line) line.AppendString(ent.Message) } // 自定义的字段 // c.writeContext(line, fields) // If there's no stacktrace key, honor that; this allows users to force // single-line output. if ent.Stack != \"\" && c.StacktraceKey != \"\" { line.AppendByte('\\n') line.AppendString(ent.Stack) } line.AppendString(c.LineEnding) return line, nil } func MyISO8601TimeEncoder(t time.Time, enc zapcore.PrimitiveArrayEncoder) { encodeTimeLayout(t, \"2006-01-02T15:04:05.000\", enc) } func encodeTimeLayout(t time.Time, layout string, enc zapcore.PrimitiveArrayEncoder) { type appendTimeEncoder interface { AppendTimeLayout(time.Time, string) } if enc, ok := enc.(appendTimeEncoder); ok { enc.AppendTimeLayout(t, layout) return } enc.AppendString(t.Format(layout)) } func GetLogger() *zap.Logger { // encoderConfig := zap.NewProductionEncoderConfig() // go.uber.org/zap/zapcore.EncoderConfig // {MessageKey: \"msg\", LevelKey: \"level\", TimeKey: \"ts\", // NameKey: \"logger\", CallerKey: \"caller\", FunctionKey: \"\", // StacktraceKey: \"stacktrace\", SkipLineEnding: false, // LineEnding: \"\\n\", EncodeLevel: go.uber.org/zap/zapcore.LowercaseLevelEncoder, // EncodeTime: main.MyISO8601TimeEncoder, // EncodeDuration: go.uber.org/zap/zapcore.SecondsDurationEncoder, // EncodeCaller: go.uber.org/zap/zapcore.ShortCallerEncoder, // EncodeName: nil, NewReflectedEncoder: nil, ConsoleSeparator: \"|\"} // json.Encoder encoderConfig := zapcore.EncoderConfig{ MessageKey: \"message\", LevelKey: \"loglevel\", TimeKey: \"time\", NameKey: \"nameKey\", CallerKey: \"caller\", FunctionKey: \"functionKey\", StacktraceKey: \"stacktraceKey\", SkipLineEnding: false, LineEnding: \"\\n\", EncodeLevel: zapcore.CapitalLevelEncoder, EncodeTime: MyISO8601TimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, EncodeName: nil, NewReflectedEncoder: nil, ConsoleSeparator: \"|\", } // 设置日志记录中时间的格式 encoderConfig.EncodeTime = MyISO8601TimeEncoder // 日志Encoder 还是JSONEncoder，把日志行格式化成JSON格式的 // encoder := zapcore.NewJSONEncoder(encoderConfig) // encoderConfig.ConsoleSeparator = \"|\" encoder := NewConsoleEncoder(encoderConfig) // encoder := zapcore.NewConsoleEncoder(encoderConfig) file, _ := os.OpenFile(\"test.log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) fileWriteSyncer := zapcore.AddSync(file) core := zapcore.NewTee( // 同时向控制台和文件写日志， 生产环境记得把控制台写入去掉，日志记录的基本是Debug 及以上，生产环境记得改成Info zapcore.NewCore(encoder, zapcore.AddSync(os.Stdout), zapcore.DebugLevel), zapcore.NewCore(encoder, fileWriteSyncer, zapcore.DebugLevel), ) opts := []zap.Option{} opts = append(opts, zap.AddCaller()) log := zap.New(core, opts...) return log } user_mem_encoder.go // Copyright (c) 2016 Uber Technologies, Inc. // // Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the \"Software\"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // // The above copyright notice and this permission notice shall be included in // all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. package log_mgr import ( \"sync\" \"time\" \"go.uber.org/zap/buffer\" \"go.uber.org/zap/zapcore\" ) // MapObjectEncoder is an ObjectEncoder backed by a simple // map[string]interface{}. It's not fast enough for production use, but it's // helpful in tests. type MapObjectEncoder struct { // Fields contains the entire encoded log context. Fields map[string]interface{} // cur is a pointer to the namespace we're currently writing to. cur map[string]interface{} } // NewMapObjectEncoder creates a new map-backed ObjectEncoder. func NewMapObjectEncoder() *MapObjectEncoder { m := make(map[string]interface{}) return &MapObjectEncoder{ Fields: m, cur: m, } } // AddArray implements ObjectEncoder. func (m *MapObjectEncoder) AddArray(key string, v zapcore.ArrayMarshaler) error { arr := &sliceArrayEncoder{elems: make([]interface{}, 0)} err := v.MarshalLogArray(arr) m.cur[key] = arr.elems return err } // AddObject implements ObjectEncoder. func (m *MapObjectEncoder) AddObject(k string, v zapcore.ObjectMarshaler) error { newMap := NewMapObjectEncoder() m.cur[k] = newMap.Fields return v.MarshalLogObject(newMap) } // AddBinary implements ObjectEncoder. func (m *MapObjectEncoder) AddBinary(k string, v []byte) { m.cur[k] = v } // AddByteString implements ObjectEncoder. func (m *MapObjectEncoder) AddByteString(k string, v []byte) { m.cur[k] = string(v) } // AddBool implements ObjectEncoder. func (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v } // AddDuration implements ObjectEncoder. func (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v } // AddComplex128 implements ObjectEncoder. func (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v } // AddComplex64 implements ObjectEncoder. func (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v } // AddFloat64 implements ObjectEncoder. func (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v } // AddFloat32 implements ObjectEncoder. func (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v } // AddInt implements ObjectEncoder. func (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v } // AddInt64 implements ObjectEncoder. func (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v } // AddInt32 implements ObjectEncoder. func (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v } // AddInt16 implements ObjectEncoder. func (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v } // AddInt8 implements ObjectEncoder. func (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v } // AddString implements ObjectEncoder. func (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v } // AddTime implements ObjectEncoder. func (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v } // AddUint implements ObjectEncoder. func (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v } // AddUint64 implements ObjectEncoder. func (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v } // AddUint32 implements ObjectEncoder. func (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v } // AddUint16 implements ObjectEncoder. func (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v } // AddUint8 implements ObjectEncoder. func (m *MapObjectEncoder) AddUint8(k string, v uint8) { m.cur[k] = v } // AddUintptr implements ObjectEncoder. func (m *MapObjectEncoder) AddUintptr(k string, v uintptr) { m.cur[k] = v } // AddReflected implements ObjectEncoder. func (m *MapObjectEncoder) AddReflected(k string, v interface{}) error { m.cur[k] = v return nil } // OpenNamespace implements ObjectEncoder. func (m *MapObjectEncoder) OpenNamespace(k string) { ns := make(map[string]interface{}) m.cur[k] = ns m.cur = ns } // sliceArrayEncoder is an ArrayEncoder backed by a simple []interface{}. Like // the MapObjectEncoder, it's not designed for production use. type sliceArrayEncoder struct { elems []interface{} } func (s *sliceArrayEncoder) AppendArray(v zapcore.ArrayMarshaler) error { enc := &sliceArrayEncoder{} err := v.MarshalLogArray(enc) s.elems = append(s.elems, enc.elems) return err } func (s *sliceArrayEncoder) AppendObject(v zapcore.ObjectMarshaler) error { m := NewMapObjectEncoder() err := v.MarshalLogObject(m) s.elems = append(s.elems, m.Fields) return err } func (s *sliceArrayEncoder) AppendReflected(v interface{}) error { s.elems = append(s.elems, v) return nil } func (s *sliceArrayEncoder) AppendBool(v bool) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendByteString(v []byte) { s.elems = append(s.elems, string(v)) } func (s *sliceArrayEncoder) AppendComplex128(v complex128) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendComplex64(v complex64) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendFloat64(v float64) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendFloat32(v float32) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendInt(v int) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendInt64(v int64) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendInt32(v int32) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendInt16(v int16) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendInt8(v int8) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendString(v string) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendTime(v time.Time) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendUint(v uint) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendUint64(v uint64) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendUint32(v uint32) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendUint16(v uint16) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendUint8(v uint8) { s.elems = append(s.elems, v) } func (s *sliceArrayEncoder) AppendUintptr(v uintptr) { s.elems = append(s.elems, v) } // A Pool is a type-safe wrapper around a sync.Pool. type Pool struct { p *sync.Pool } // NewPool constructs a new Pool. func NewPool() Pool { return Pool{p: &sync.Pool{ New: func() interface{} { return &Buffer{bs: make([]byte, 0, _size)} }, }} } // Get retrieves a Buffer from the pool, creating one if necessary. func (p Pool) Get() *Buffer { buf := p.p.Get().(*Buffer) buf.Reset() buf.pool = p return buf } func (p Pool) put(buf *Buffer) { p.p.Put(buf) } var ( _pool = buffer.NewPool() // UserGet retrieves a buffer from the pool, creating one if necessary. UserGet = _pool.Get ) func addFields(enc zapcore.ObjectEncoder, fields []zapcore.Field) { for i := range fields { fields[i].AddTo(enc) } } user_json_encoder.go package log_mgr // Copyright (c) 2016 Uber Technologies, Inc. // // Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the \"Software\"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // // The above copyright notice and this permission notice shall be included in // all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. import ( \"encoding/base64\" \"math\" \"sync\" \"time\" \"unicode/utf8\" \"encoding/json\" \"io\" \"go.uber.org/zap/buffer\" \"go.uber.org/zap/zapcore\" ) // ReflectedEncoder serializes log fields that can't be serialized with Zap's // JSON encoder. These have the ReflectType field type. // Use EncoderConfig.NewReflectedEncoder to set this. type ReflectedEncoder interface { // Encode encodes and writes to the underlying data stream. Encode(interface{}) error } func defaultReflectedEncoder(w io.Writer) zapcore.ReflectedEncoder { enc := json.NewEncoder(w) // For consistency with our custom JSON encoder. enc.SetEscapeHTML(false) return enc } // For JSON-escaping; see jsonEncoder.safeAddString below. const _hex = \"0123456789abcdef\" var _jsonPool = sync.Pool{New: func() interface{} { return &jsonEncoder{} }} func getJSONEncoder() *jsonEncoder { return _jsonPool.Get().(*jsonEncoder) } func putJSONEncoder(enc *jsonEncoder) { if enc.reflectBuf != nil { enc.reflectBuf.Free() } enc.EncoderConfig = nil enc.buf = nil enc.spaced = false enc.openNamespaces = 0 enc.reflectBuf = nil enc.reflectEnc = nil _jsonPool.Put(enc) } type jsonEncoder struct { *zapcore.EncoderConfig buf *buffer.Buffer spaced bool // include spaces after colons and commas openNamespaces int // for encoding generic values by reflection reflectBuf *buffer.Buffer reflectEnc zapcore.ReflectedEncoder } // NewJSONEncoder creates a fast, low-allocation JSON encoder. The encoder // appropriately escapes all field keys and values. // // Note that the encoder doesn't deduplicate keys, so it's possible to produce // a message like // {\"foo\":\"bar\",\"foo\":\"baz\"} // This is permitted by the JSON specification, but not encouraged. Many // libraries will ignore duplicate key-value pairs (typically keeping the last // pair) when unmarshaling, but users should attempt to avoid adding duplicate // keys. func NewJSONEncoder(cfg zapcore.EncoderConfig) zapcore.Encoder { return newJSONEncoder(cfg, false) } func newJSONEncoder(cfg zapcore.EncoderConfig, spaced bool) *jsonEncoder { if cfg.SkipLineEnding { cfg.LineEnding = \"\" } else if cfg.LineEnding == \"\" { cfg.LineEnding = zapcore.DefaultLineEnding } // If no EncoderConfig.NewReflectedEncoder is provided by the user, then use default if cfg.NewReflectedEncoder == nil { cfg.NewReflectedEncoder = defaultReflectedEncoder } return &jsonEncoder{ EncoderConfig: &cfg, buf: UserGet(), spaced: spaced, } } func (enc *jsonEncoder) AddArray(key string, arr zapcore.ArrayMarshaler) error { enc.addKey(key) return enc.AppendArray(arr) } func (enc *jsonEncoder) AddObject(key string, obj zapcore.ObjectMarshaler) error { enc.addKey(key) return enc.AppendObject(obj) } func (enc *jsonEncoder) AddBinary(key string, val []byte) { enc.AddString(key, base64.StdEncoding.EncodeToString(val)) } func (enc *jsonEncoder) AddByteString(key string, val []byte) { enc.addKey(key) enc.AppendByteString(val) } func (enc *jsonEncoder) AddBool(key string, val bool) { enc.addKey(key) enc.AppendBool(val) } func (enc *jsonEncoder) AddComplex128(key string, val complex128) { enc.addKey(key) enc.AppendComplex128(val) } func (enc *jsonEncoder) AddComplex64(key string, val complex64) { enc.addKey(key) enc.AppendComplex64(val) } func (enc *jsonEncoder) AddDuration(key string, val time.Duration) { enc.addKey(key) enc.AppendDuration(val) } func (enc *jsonEncoder) AddFloat64(key string, val float64) { enc.addKey(key) enc.AppendFloat64(val) } func (enc *jsonEncoder) AddFloat32(key string, val float32) { enc.addKey(key) enc.AppendFloat32(val) } func (enc *jsonEncoder) AddInt64(key string, val int64) { enc.addKey(key) enc.AppendInt64(val) } func (enc *jsonEncoder) resetReflectBuf() { if enc.reflectBuf == nil { enc.reflectBuf = UserGet() enc.reflectEnc = enc.NewReflectedEncoder(enc.reflectBuf) } else { enc.reflectBuf.Reset() } } var nullLiteralBytes = []byte(\"null\") // Only invoke the standard JSON encoder if there is actually something to // encode; otherwise write JSON null literal directly. func (enc *jsonEncoder) encodeReflected(obj interface{}) ([]byte, error) { if obj == nil { return nullLiteralBytes, nil } enc.resetReflectBuf() if err := enc.reflectEnc.Encode(obj); err != nil { return nil, err } enc.reflectBuf.TrimNewline() return enc.reflectBuf.Bytes(), nil } func (enc *jsonEncoder) AddReflected(key string, obj interface{}) error { valueBytes, err := enc.encodeReflected(obj) if err != nil { return err } enc.addKey(key) _, err = enc.buf.Write(valueBytes) return err } func (enc *jsonEncoder) OpenNamespace(key string) { enc.addKey(key) enc.buf.AppendByte('{') enc.openNamespaces++ } func (enc *jsonEncoder) AddString(key, val string) { enc.addKey(key) enc.AppendString(val) } func (enc *jsonEncoder) AddTime(key string, val time.Time) { enc.addKey(key) enc.AppendTime(val) } func (enc *jsonEncoder) AddUint64(key string, val uint64) { enc.addKey(key) enc.AppendUint64(val) } func (enc *jsonEncoder) AppendArray(arr zapcore.ArrayMarshaler) error { enc.addElementSeparator() enc.buf.AppendByte('[') err := arr.MarshalLogArray(enc) enc.buf.AppendByte(']') return err } func (enc *jsonEncoder) AppendObject(obj zapcore.ObjectMarshaler) error { // Close ONLY new openNamespaces that are created during // AppendObject(). old := enc.openNamespaces enc.openNamespaces = 0 enc.addElementSeparator() enc.buf.AppendByte('{') err := obj.MarshalLogObject(enc) enc.buf.AppendByte('}') enc.closeOpenNamespaces() enc.openNamespaces = old return err } func (enc *jsonEncoder) AppendBool(val bool) { enc.addElementSeparator() enc.buf.AppendBool(val) } func (enc *jsonEncoder) AppendByteString(val []byte) { enc.addElementSeparator() enc.buf.AppendByte('\"') enc.safeAddByteString(val) enc.buf.AppendByte('\"') } // appendComplex appends the encoded form of the provided complex128 value. // precision specifies the encoding precision for the real and imaginary // components of the complex number. func (enc *jsonEncoder) appendComplex(val complex128, precision int) { enc.addElementSeparator() // Cast to a platform-independent, fixed-size type. r, i := float64(real(val)), float64(imag(val)) enc.buf.AppendByte('\"') // Because we're always in a quoted string, we can use strconv without // special-casing NaN and +/-Inf. enc.buf.AppendFloat(r, precision) // If imaginary part is less than 0, minus (-) sign is added by default // by AppendFloat. if i >= 0 { enc.buf.AppendByte('+') } enc.buf.AppendFloat(i, precision) enc.buf.AppendByte('i') enc.buf.AppendByte('\"') } func (enc *jsonEncoder) AppendDuration(val time.Duration) { cur := enc.buf.Len() if e := enc.EncodeDuration; e != nil { e(val, enc) } if cur == enc.buf.Len() { // User-supplied EncodeDuration is a no-op. Fall back to nanoseconds to keep // JSON valid. enc.AppendInt64(int64(val)) } } func (enc *jsonEncoder) AppendInt64(val int64) { enc.addElementSeparator() enc.buf.AppendInt(val) } func (enc *jsonEncoder) AppendReflected(val interface{}) error { valueBytes, err := enc.encodeReflected(val) if err != nil { return err } enc.addElementSeparator() _, err = enc.buf.Write(valueBytes) return err } func (enc *jsonEncoder) AppendString(val string) { enc.addElementSeparator() enc.buf.AppendByte('\"') enc.safeAddString(val) enc.buf.AppendByte('\"') } func (enc *jsonEncoder) AppendTimeLayout(time time.Time, layout string) { enc.addElementSeparator() enc.buf.AppendByte('\"') enc.buf.AppendTime(time, layout) enc.buf.AppendByte('\"') } func (enc *jsonEncoder) AppendTime(val time.Time) { cur := enc.buf.Len() if e := enc.EncodeTime; e != nil { e(val, enc) } if cur == enc.buf.Len() { // User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep // output JSON valid. enc.AppendInt64(val.UnixNano()) } } func (enc *jsonEncoder) AppendUint64(val uint64) { enc.addElementSeparator() enc.buf.AppendUint(val) } func (enc *jsonEncoder) AddInt(k string, v int) { enc.AddInt64(k, int64(v)) } func (enc *jsonEncoder) AddInt32(k string, v int32) { enc.AddInt64(k, int64(v)) } func (enc *jsonEncoder) AddInt16(k string, v int16) { enc.AddInt64(k, int64(v)) } func (enc *jsonEncoder) AddInt8(k string, v int8) { enc.AddInt64(k, int64(v)) } func (enc *jsonEncoder) AddUint(k string, v uint) { enc.AddUint64(k, uint64(v)) } func (enc *jsonEncoder) AddUint32(k string, v uint32) { enc.AddUint64(k, uint64(v)) } func (enc *jsonEncoder) AddUint16(k string, v uint16) { enc.AddUint64(k, uint64(v)) } func (enc *jsonEncoder) AddUint8(k string, v uint8) { enc.AddUint64(k, uint64(v)) } func (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) } func (enc *jsonEncoder) AppendComplex64(v complex64) { enc.appendComplex(complex128(v), 32) } func (enc *jsonEncoder) AppendComplex128(v complex128) { enc.appendComplex(complex128(v), 64) } func (enc *jsonEncoder) AppendFloat64(v float64) { enc.appendFloat(v, 64) } func (enc *jsonEncoder) AppendFloat32(v float32) { enc.appendFloat(float64(v), 32) } func (enc *jsonEncoder) AppendInt(v int) { enc.AppendInt64(int64(v)) } func (enc *jsonEncoder) AppendInt32(v int32) { enc.AppendInt64(int64(v)) } func (enc *jsonEncoder) AppendInt16(v int16) { enc.AppendInt64(int64(v)) } func (enc *jsonEncoder) AppendInt8(v int8) { enc.AppendInt64(int64(v)) } func (enc *jsonEncoder) AppendUint(v uint) { enc.AppendUint64(uint64(v)) } func (enc *jsonEncoder) AppendUint32(v uint32) { enc.AppendUint64(uint64(v)) } func (enc *jsonEncoder) AppendUint16(v uint16) { enc.AppendUint64(uint64(v)) } func (enc *jsonEncoder) AppendUint8(v uint8) { enc.AppendUint64(uint64(v)) } func (enc *jsonEncoder) AppendUintptr(v uintptr) { enc.AppendUint64(uint64(v)) } func (enc *jsonEncoder) Clone() zapcore.Encoder { clone := enc.clone() clone.buf.Write(enc.buf.Bytes()) return clone } func (enc *jsonEncoder) clone() *jsonEncoder { clone := getJSONEncoder() clone.EncoderConfig = enc.EncoderConfig clone.spaced = enc.spaced clone.openNamespaces = enc.openNamespaces clone.buf = UserGet() return clone } func (enc *jsonEncoder) EncodeEntry(ent zapcore.Entry, fields []zapcore.Field) (*buffer.Buffer, error) { final := enc.clone() final.buf.AppendByte('{') if final.LevelKey != \"\" && final.EncodeLevel != nil { final.addKey(final.LevelKey) cur := final.buf.Len() final.EncodeLevel(ent.Level, final) if cur == final.buf.Len() { // User-supplied EncodeLevel was a no-op. Fall back to strings to keep // output JSON valid. final.AppendString(ent.Level.String()) } } if final.TimeKey != \"\" { final.AddTime(final.TimeKey, ent.Time) } if ent.LoggerName != \"\" && final.NameKey != \"\" { final.addKey(final.NameKey) cur := final.buf.Len() nameEncoder := final.EncodeName // if no name encoder provided, fall back to FullNameEncoder for backwards // compatibility if nameEncoder == nil { nameEncoder = zapcore.FullNameEncoder } nameEncoder(ent.LoggerName, final) if cur == final.buf.Len() { // User-supplied EncodeName was a no-op. Fall back to strings to // keep output JSON valid. final.AppendString(ent.LoggerName) } } if ent.Caller.Defined { if final.CallerKey != \"\" { final.addKey(final.CallerKey) cur := final.buf.Len() final.EncodeCaller(ent.Caller, final) if cur == final.buf.Len() { // User-supplied EncodeCaller was a no-op. Fall back to strings to // keep output JSON valid. final.AppendString(ent.Caller.String()) } } if final.FunctionKey != \"\" { final.addKey(final.FunctionKey) final.AppendString(ent.Caller.Function) } } if final.MessageKey != \"\" { final.addKey(enc.MessageKey) final.AppendString(ent.Message) } if enc.buf.Len() > 0 { final.addElementSeparator() final.buf.Write(enc.buf.Bytes()) } addFields(final, fields) final.closeOpenNamespaces() if ent.Stack != \"\" && final.StacktraceKey != \"\" { final.AddString(final.StacktraceKey, ent.Stack) } final.buf.AppendByte('}') final.buf.AppendString(final.LineEnding) ret := final.buf putJSONEncoder(final) return ret, nil } func (enc *jsonEncoder) closeOpenNamespaces() { for i := 0; i = utf8.RuneSelf { return false } if 0x20 >4]) enc.buf.AppendByte(_hex[b&0xF]) } return true } func (enc *jsonEncoder) tryAddRuneError(r rune, size int) bool { if r == utf8.RuneError && size == 1 { enc.buf.AppendString(`\\ufffd`) return true } return false } user_encoder.go package log_mgr // Copyright (c) 2016 Uber Technologies, Inc. // // Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the \"Software\"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // // The above copyright notice and this permission notice shall be included in // all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. import ( \"sync\" \"go.uber.org/zap/buffer\" \"go.uber.org/zap/zapcore\" ) var _sliceEncoderPool = sync.Pool{ New: func() interface{} { return &sliceArrayEncoder{elems: make([]interface{}, 0, 2)} }, } func getSliceEncoder() *sliceArrayEncoder { return _sliceEncoderPool.Get().(*sliceArrayEncoder) } func putSliceEncoder(e *sliceArrayEncoder) { e.elems = e.elems[:0] _sliceEncoderPool.Put(e) } type consoleEncoder struct { *jsonEncoder } // NewConsoleEncoder creates an encoder whose output is designed for human - // rather than machine - consumption. It serializes the core log entry data // (message, level, timestamp, etc.) in a plain-text format and leaves the // structured context as JSON. // // Note that although the console encoder doesn't use the keys specified in the // encoder configuration, it will omit any element whose key is set to the empty // string. func NewConsoleEncoder(cfg zapcore.EncoderConfig) zapcore.Encoder { if cfg.ConsoleSeparator == \"\" { // Use a default delimiter of '\\t' for backwards compatibility cfg.ConsoleSeparator = \"\\t\" } return consoleEncoder{newJSONEncoder(cfg, true)} } func (c consoleEncoder) Clone() zapcore.Encoder { return consoleEncoder{c.jsonEncoder.Clone().(*jsonEncoder)} } // func (c consoleEncoder) writeContext(line *buffer.Buffer, extra []zapcore.Field) { // context := c.jsonEncoder.Clone().(*jsonEncoder) // defer func() { // // putJSONEncoder assumes the buffer is still used, but we write out the buffer so // // we can free it. // context.buf.Free() // putJSONEncoder(context) // }() // addFields(context, extra) // context.closeOpenNamespaces() // if context.buf.Len() == 0 { // return // } // c.addSeparatorIfNecessary(line) // line.AppendByte('{') // line.Write(context.buf.Bytes()) // line.AppendByte('}') // } func (c consoleEncoder) addSeparatorIfNecessary(line *buffer.Buffer) { if line.Len() > 0 { line.AppendString(c.ConsoleSeparator) } } user_buffer.go package log_mgr import ( \"strconv\" \"time\" ) const _size = 1024 // by default, create 1 KiB buffers // Buffer is a thin wrapper around a byte slice. It's intended to be pooled, so // the only way to construct one is via a Pool. type Buffer struct { bs []byte pool Pool } // AppendByte writes a single byte to the Buffer. func (b *Buffer) AppendByte(v byte) { b.bs = append(b.bs, v) } // AppendString writes a string to the Buffer. func (b *Buffer) AppendString(s string) { b.bs = append(b.bs, s...) } // AppendInt appends an integer to the underlying buffer (assuming base 10). func (b *Buffer) AppendInt(i int64) { b.bs = strconv.AppendInt(b.bs, i, 10) } // AppendTime appends the time formatted using the specified layout. func (b *Buffer) AppendTime(t time.Time, layout string) { b.bs = t.AppendFormat(b.bs, layout) } // AppendUint appends an unsigned integer to the underlying buffer (assuming // base 10). func (b *Buffer) AppendUint(i uint64) { b.bs = strconv.AppendUint(b.bs, i, 10) } // AppendBool appends a bool to the underlying buffer. func (b *Buffer) AppendBool(v bool) { b.bs = strconv.AppendBool(b.bs, v) } // AppendFloat appends a float to the underlying buffer. It doesn't quote NaN // or +/- Inf. func (b *Buffer) AppendFloat(f float64, bitSize int) { b.bs = strconv.AppendFloat(b.bs, f, 'f', -1, bitSize) } // Len returns the length of the underlying byte slice. func (b *Buffer) Len() int { return len(b.bs) } // Cap returns the capacity of the underlying byte slice. func (b *Buffer) Cap() int { return cap(b.bs) } // Bytes returns a mutable reference to the underlying byte slice. func (b *Buffer) Bytes() []byte { return b.bs } // String returns a string copy of the underlying byte slice. func (b *Buffer) String() string { return string(b.bs) } // Reset resets the underlying byte slice. Subsequent writes re-use the slice's // backing array. func (b *Buffer) Reset() { b.bs = b.bs[:0] } // Write implements io.Writer. func (b *Buffer) Write(bs []byte) (int, error) { b.bs = append(b.bs, bs...) return len(bs), nil } // WriteByte writes a single byte to the Buffer. // // Error returned is always nil, function signature is compatible // with bytes.Buffer and bufio.Writer func (b *Buffer) WriteByte(v byte) error { b.AppendByte(v) return nil } // WriteString writes a string to the Buffer. // // Error returned is always nil, function signature is compatible // with bytes.Buffer and bufio.Writer func (b *Buffer) WriteString(s string) (int, error) { b.AppendString(s) return len(s), nil } // TrimNewline trims any final \"\\n\" byte from the end of the buffer. func (b *Buffer) TrimNewline() { if i := len(b.bs) - 1; i >= 0 { if b.bs[i] == '\\n' { b.bs = b.bs[:i] } } } // Free returns the Buffer to its Pool. // // Callers must not retain references to the Buffer after calling Free. func (b *Buffer) Free() { b.pool.put(b) } "},"blog/Dart/40m_Learn_dart.html":{"url":"blog/Dart/40m_Learn_dart.html","title":"快速入门Dart基础","keywords":"","body":"快速入门Dart基础 小丢子 27 人赞同了该文章 教大家快速学习一门新语言： 第一是零基础：那我们只能靠自己脚踏实地的多写多想慢慢熟悉你所选择的语言 ，没有别的办法。（但是dart确实目前为止最好学的没有之一的语言） 第二是有基础：小伙伴们如何快速学习一门新语言，其实很简单，我们可以根据我们当前所掌握或者熟悉的语言对比，比如：js、java、swift等等任意一门都可以，那么剩下来我们只需要掌握与之不同的语法，然后在靠自己多写多想慢慢熟悉。 一、开篇（请记住并了解这些万能的规则） 一切变量皆是对象，每个对象都是类的实例。int、double、函数、 null 等都是对象，所有对象都继承自 Object 类 Dart可基于AOT（Ahead Of Time）编译，即编译成平台的本地代码，运行性能高。 Dart也可基于JIT（Just In Time）编译，编译快速，可热加载，使开发周期加倍提升（Flutter亚秒级有状态热重载） Dart可以更轻松地创建以60fps运行的流畅动画和转场。Dart在没有锁的情况下进行对象分配和垃圾回收 Dart语法结合Java与JavaScript语法特点，几乎没有令人不适的怪异语法，使Java程序员倍感亲切，快速上手 Dart 没有关于 public、protected、private 的关键字。通过为变量标识符添加下划线前缀，表明该标识符对其库是私有的 Dart支持顶级函数、静态函数、实例函数，也允许在函数中嵌套函数，即局部函数。类似的，dart 也支持顶级变量、静态变量和实例变量 Dart 是强类型语言，但由于具备类型推导功能所以类型声明是可选的 二、Dart快速入门基础目录： 本文分三节讲解： | 章节 | 介绍 | | ---- | ---- | | | 上： | | | 中： | | | 下： | 三、开发工具选择 编译器主要采用Android Studio编译器 同时按照国际惯例使用Dart完成一个：\"Hello，World!\" 并输入运行结果： import 'dart:core'; void main() { print('Hello，World'); } 四、变量 Dart中定义变量有两种方式: 一、静态类型语言常用的方式，显式指定变量类型。 二、动态语言的常用方式，不指定类型，由vm自动推断。 一切变量皆是对象，每个对象都是类的实例。int、double、函数、 null 等都是对象，所有对象都继承自 Object 类。下面我们看看如何声明变量： 变量是一个引用，未初始化的变量值是Null如下。 import 'dart:core'; void main() { String name; print('$name'); //输出为null } 上面我们提到了显示指定变量类型如下： import 'dart:core'; void main() { String name =\"黄药师\"; int age =10; print('$name''----$age'); //输出:黄药师----10 } 动态语言的常用方式，不指定类型，由vm自动推断。 import 'dart:core'; void main() { String name =\"黄药师\"; name ='周伯通'; print('$name'); //输出:周伯通 } Dart 语言是强类型语言，无法将一个已声明具体变量类型的变量赋值为另一个无继承关系的变量 import 'dart:core'; void main() { String name =\"黄药师\"; name =10; print('$name'); } 这种赋值的时候就会报错： import 'dart:core'; void main() { int age =10; age =10.0; //这种在赋值的时候就已经报错 print('$age'); } 但是这个地方有个需要注意的地方就是int 和double 类都是num的子类如下面写法是合法。 import 'dart:core'; void main() { num age =10; age =10.0; //这种在赋值合法 print('$age'); } 1、var（官方风格指南建议使用var） var：在声明变量在赋值的那一刻，就已经决定了它是什么类型。 上面这句话是什么意思尼？其实很简单： import 'dart:core'; void main() { //age 已经确定为num类型并为其赋值18岁，如果你赋值字符串，那么就会报错 var age =18; age ='18'; print('$age'); } import 'dart:core'; void main() { //age 已经确定为num类型并但是没有为其赋值，如果你赋值字符串那么是正确 var age; age =18; age ='18'; print('$age'); } 2、Object 一切变量皆是对象，每个对象都是类的实例。int、double、函数、 null 等都是对象，所有对象都继承自 Object 类 import 'dart:core'; void main() { Object age ='18'; age =18; print('$age'); } 3、dynamic dynamic类似java中的Object ，所以声明的变量行为与Object一样，使用也是一样，但是我们需要知道的是：dynamic不是在编译时确定类型的，而是在运行时：这句话有点懵，到底是什么意思呢？ import 'dart:core'; void main() { dynamic name ='黄药师'; print(name.runtimeType); //输入：String name =18; print(name.runtimeType); //输入：int } 说明： 在声明变量的时候，也可以选择加上具体 类型：String name = “黄药师” 没有初始化的变量自动获取一个默认值为 null（类型为数字的 变量如何没有初始化其值也是 null）。 对于局部变量，按照dart官方建议使用var来声明变量 4、final与const final 和const 从本质上看不出区别：如果你希望一个变量在赋值后其引用不能再改变，可以通过final或const这两个关键字来实现。 * final是运行时常量，final的要求是其声明的变量在赋值以后是不能在改变: final有两种使用场景 类中的变量声明，必须在声明时赋值。 类中的成员变量声明，可以在声明时候赋值，也可以通过构造函数赋值如： import 'package:flutter/cupertino.dart'; class TestDart extends StatefulWidget{ final String name; TestDart(this.name); @override State const是编译期常量。这里关键点区分什么是编译时常量，说白了就是其定义的值必须是一个字面常量值如下图： 针对final 和const 理解的有点模糊的可以参考这篇文章： 可以参考这里Flutter 知识梳理（Dart）-Dart中static final const 区别 五、操作符： Dart中的操作符与面向对象语言中（如：java）操作符绝大多数是相同。该有的都有，不该有的Dart也有 。 | 操作符 | 说明 | | :----- | ----------: | | + | 加 | | _ | 减 | | * | 乘 | | / | 除 | | % | 取模运算 元 | | ~/ | 整除 | | = | 箭头函数 | import 'dart:core'; void main() { var i = 6; var r = 2; //加法： print('${i + r}'); //输出：8 //减法 print('${i - r}'); //输出：4 //乘法 print('${i * r}'); //输出：12 //除法 print('${i / r}'); //输出：3.0 //取模运算 print('${i % r}'); //输出：0 //整除 print('${i ~/ r}'); //输出：3 } 类型判断操作符 as类型转换is如果对象是指定的类型返回 Trueis！如果对象是指定的类型返回 False 注意点：as 操作符把对象转换为特定的类型，但是如果无法完成转换则会抛出一个异常 import 'dart:core'; void main() { var name = \"黄药师\"; if (name is String) { //判断条件为 true print(\"name is String\"); } var age = 1; if (age is! String) { //判断条件为 true print(\"age is String\"); } //说明：由于age 是int 类型 不是一个String类型，所以活报如下错误 //'int' is not a subtype of type 'String' in type cast String newResult = age as String; } 赋值操作符 | 操作符 | 说明 | | :----- | ---------------: | | = | 赋值操作符 | | += | 加和赋值操作符 | | -= | 减和赋值操作符 | | *= | 乘和赋值操作符 | | %= | 取模和赋值操作符 | | /= | 除和赋值操作符 | | ??= | 值为null的变量值 | import 'dart:core'; void main() { var age =20; //加和赋值操作符 print('${age+=10}'); //减和赋值操作符 print('${age-=10}'); //乘和赋值操作符 print('${age*=10}'); //除和赋值操作符 double newAge =20.0; print('${newAge /= 10.0}'); //取模和赋值操作符 double price =230.0; print('${price %= 10.0}'); String name; name ??= \"黄药师\"; // 如果 name 是 null，则把等于号右边的值 赋值给 name； // 如果不是 null，则 name 的值保持不变 print(\"$name\"); //输出：黄药师 } 替代条件表达式操作符 在Dart中有两种特殊操作符可以替代 if-else 语句 三目运算符 ?? import 'dart:core'; void main() { var age = 10; print(printAge1(age)); print(printAge2(age)); print(printAge3(age)); } //if-else printAge1(age) { if (age == 10) { return age; } return age; //输出：10 } //第一种替换if-else 使用三目运算符 printAge2(int age) { return age == 10 ? age : 0; //输出：10 } //第二种用\"??\"替换if-else printAge3(int age) { return age == 10 ?? 0; //输出：true } 级联操作符 级联操作符 (..) 可以在同一个对象上 连续调用多个函数以及访问成员变量。 使用级联操作符可以避免创建 临时变量， 并且写出来的代码看起来 更加流畅： import 'dart:core'; void main() { var list = List(); print(\"${list..add(\"黄药师\")..add(\"郭靖\")}\"); //输出：黄药师,郭靖 } 安全操作符 Dart提供了 ?.操作符。左边的操作对象 如果 为 null 则返回 null import 'dart:core'; void main() { String name; //没有添加\"?\"空指针 print(name.length); // The getter 'length' was called on null. //添加\"？\" print(name?.length); //输出null } 六、内置类型： 1、num（数值） dart的num类型有量两种分别是int 和double两种，这两种都是num的子类。 void main() { var age = 18; print(age.runtimeType); //输出 int var price = 8.0; print(price.runtimeType); //输出：double num year = 2020; print(year.runtimeType); //输出：int year = 2020.0; print(year.runtimeType); //输出：double int days = 10; print(days.runtimeType); //输出：int double limit = 8.90; print(limit.runtimeType); //输出：double } 同时num也支持一些数据类型的转换： void main() { var age = '18'; print(age.runtimeType); //输出：String 类型 int parseAge = int.parse(age); print(parseAge.runtimeType); //输出：int 类型 } 2、string（字符串） Dart字符串是UTF-16编码的字符序列，可以使用单引号或者双引号来创建字符串，单引号和双引号可以嵌套使用，否则需要使用\\进行转义。字符串中也可以引用变量与表达式，同时可以实现字符串拼接功能 import 'dart:core'; void main() { var name = '黄药师'; print(name.runtimeType); //输出：String 类型 var newName1 = \"my name is $name\"; print(newName1); //输出：my name is 黄药师 //和上面反之，需要添加上{} var nameName2 = \"my name is ${User().name}\"; print(nameName2); //输出：my name is 黄药师 } class User { var age =10; var name =\"黄药师\"; } 提供一个 r 前缀可以创建一个 “原始 raw” 字符串，说白了就是不需要转义（如果添加上转义字符那么将会失效）如下： import 'dart:core'; void main() { //r:不需要转义 print(r\"换行符: \\n\"); //输出：换行符：\\n print(\"换行符: \\\\n\"); //输出：换行符：\\n } 3、bool（布尔值） Dart有个类型名字为bool 类型，而在Dart中只有两个对象是布尔类型：分别是true和false。在Dart中还强类型检查，只有当为true的时候才会真。 import 'dart:core'; void main() { bool isLoading; print('$isLoading'); //输出：null; isLoading =true; print('$isLoading'); //输出：true; } 4、list（数组） 几乎所有的编程语言中数组是必不可少的，而在Dart中 list 也是必不可少的。 下面我们来看一下List一些基本用法: 初始化 import 'dart:core'; void main() { var names = List(); print(names.length); //输出：0; var names1 = List(2); print(names1.length); //输出：2; //如果想要为 List 添加不同数据类型的变量，则需要直接只买数据类型为Object var names2 = List 常用属性和方法 import 'dart:core'; import 'package:myfirstflutter/test/user.dart'; void main() { var names1 = [1, 2, 3]; print(names1.length); //输出：0; //排序 List 添加数据 import 'dart:core'; void main() { var names1 = ['杨过', '小龙女', '黄蓉']; //添加数据 names1.add('丘处机'); print(names1.length); //输出：4; var names2 = List(2); ///当执行add 时候会报错：Cannot add to a fixed-length list ///（固定长度的list是不能通过add添加数据） ///names2.add(1); //固定长度的list使用一下方式可以设置数据 names2[0] = '黄药师'; names2[1] = '欧阳锋'; names2.forEach((v) { print('$v'); //输出：黄药师 欧阳锋 }); var names3 = ['杨过', '小龙女', '黄蓉']; var names4 = ['1', '2', '3']; //添加全部元素 names3.addAll(names4); names3.forEach((v) { print('$v'); //输出：杨过 小龙女 黄蓉 1 2 3 }); } 删除数据 import 'dart:core'; void main() { var names1 = ['杨过', '小龙女', '黄蓉', '丘处机', '黄药师']; //删除指定元素 names1.remove('杨过'); print(names1); //输出：小龙女 黄蓉 丘处机 黄药师 //删除最后一个元素 names1.removeLast(); print(names1); //输出：小龙女 黄蓉 丘处机 //删除指定位置元素 names1.removeAt(names1.length - 1); print(names1); //输出：小龙女 黄蓉 //删除指定位区域元素 names1.removeRange(0, 1); print(names1); //输出 黄蓉 //下面这个方法是将列表List中的toString只有的字符串的长度等于3的元素全部删除 names1.removeWhere((item) =item.toString().length==3); print('删除列表中toString后长度为3的元素：==$names1'); } 以上还少“改”和“查” 其实这些在上面的例子代码中已经存在了一些，这里留个大家一个练习题：可以自行把“改”和“查”自己总结一下 5、Map（集合） Map和lList一样基本上只要学习开发语言map也是必不可少的一部分，Map是键值对相关的对象。 键和值可以是任何类型的对象。每个键只出现一次， 而一个值则可以出现多次。 import 'dart:core'; void main() { //直接声明，用{}表示。里面写key和value 每组键值对中间用逗号隔开 var names = {'name1': '黄药师', 'name2': '杨过', 'name3': '老顽童'}; print(names); //输出：{name1:黄药师，name2: 杨过, name3:老顽童} var names1 = Map(); names1['name1'] = '黄蓉'; names1['name2'] = '黄药师'; names1['name3'] = '郭靖'; print(names1); //{'name1': '黄蓉', 'name2': '黄药师', 'name3': '郭靖'}; //限定Map 可以存储的数据类型 var names2 = Map和List一样，同样有增删改查功能 七、分支与循环： 分支 Dart分支目前有if-else 和switch两种 if条件分支： import 'dart:core'; void main() { var age = 18; if (age switch条件分支: import 'dart:core'; void main() { // 在switch的case中可以使用整数、字符串、枚举类型和编译时常量 String name = '黄药师'; switch (name) { case '郭靖': break; case '老顽童': break; default: print('Default'); } } Dart中循环支持 for、while 以及 do-while 三种。 import 'dart:core'; void main() { // for循环 for (int i = 0; i 但是在Dart 还有一些特有的系统循环函数 import 'dart:core'; void main() { var names = [\"张无忌\", \"小龙女\", \"赵敏\"]; // for...in...循环，是增强for for (var it in names) { print(it); // 输出：\"张无忌\",\"小龙女\",\"赵敏\" } //forEach循环。其参数为一个Function对象，这里传入一个匿名函数 names.forEach((v) { print(v); // 输出：\"张无忌\",\"小龙女\",\"赵敏\" }); names.forEach((v) = print(v)); //输出：\"张无忌\",\"小龙女\",\"赵敏\" } 我们在来看一下在Dart中怎么去对一组Map数据进行循环 import 'dart:core'; void main() { var myMap = {'name': '黄药师', 'age': '50', 'skills': '弹指神通'}; //forEach遍历Map myMap.forEach( (k, v) = print(\"$k : $v\")); //输出：name : 黄药师 age : 50 skills : 弹指神通 //根据键获取值来遍历。通过keys返回Map中所有键的集合 for (var k in myMap.keys) { print(\"$k : ${myMap[k]}\");//输出：name : 黄药师 age : 50 skills : 弹指神通 } } 总结： 看是不是超级好上手，好操作~其实Dart的整个学习起来还是蛮简单的，对于有基础的老司机更简单一些。分分钟敲起来~ 这篇文章就简单的介绍到这里如何短时间快速入门Dart，避免入坑。由于是想让大家快速入门Flutter，所以针对上面的这些章节我们讲解的只是一些在开发Flutter 过程中常用的一些方法和函数。如果要想对Dart有更深的了解和学习，后期可以关注我哦，如有问题可以直接在下方留言。 感觉不错可以点赞加关注，我会持续输出优质的文章。 "},"blog/Dart/Dart_logic.html":{"url":"blog/Dart/Dart_logic.html","title":"Dart 逻辑运算符","keywords":"","body":"Dart 逻辑运算符 cekiasoo 2018年09月22日 16:06 · 阅读 1894 一、什么是逻辑运算符 逻辑运算符是表示逻辑与、逻辑或、逻辑非的，好像高中数学有讲这个， 运算符 解释 && 逻辑与 \\ \\ 逻辑或 !expr 逻辑非 二、逻辑运算符的用法 （一） 逻辑与 逻辑与在 Dart 用 \"&&\" 表示，\"&&\" 的左边和右边写条件，当两个条件为真时返回true, 否则返回 false, 比如说有一把锁是要两把不同的钥匙才能解开的，如果只有其中一把钥匙是解不开的，两把都没有就更不用说了（我砸锁不行么） 用法：条件 A && 条件 B 逻辑与真值表 条件 A 条件 B 结果 true true true true false false false true false false false false bool hasKey1 = true; bool hasKey2 = false; print(hasKey1 && hasKey2); 复制代码 bool hasKey1 = true; bool hasKey2 = true; print(hasKey1 && hasKey2); 复制代码 （二） 逻辑或 逻辑或在 Dart 用 \"||\" 表示，\"||\" 的左边和右边写条件，当两个条件只要有一个为真时返回true, 否则返回 false，比如说电灯是可以设置两个开关的，只要其中一个开关通电了就可以亮，只有两个开关都没通时才没亮， 用法：条件 A && 条件 B 逻辑或真值表 条件 A 条件 B 结果 true true true true false true false true true false false false bool switch1 = true; bool switch2 = false; print(switch1 || switch2); 复制代码 bool switch1 = false; bool switch2 = false; print(switch1 || switch2); 复制代码 （三） 逻辑非 逻辑非在 Dart 用 \"!expr\" 表示, expr 即 expression, 如果条件是真的结果就是 false, 如果条件是假的那结果是 true, 比如说要去上班，加上非之后就是不去上班， bool goToWork = true; print(!goToWork); 复制代码 bool goToWork = false; print(!goToWork); 复制代码 "},"blog/Dart/dart_bit_compute.html":{"url":"blog/Dart/dart_bit_compute.html","title":"Dart 按位运算符","keywords":"","body":"Dart 按位运算符 cekiasoo 2018年09月22日 16:09 · 阅读 2892 一、什么是按位运算符 按位运算符就是操作整数二进制位的运算，Dart 中按位操作符有 运算符 解释 & 按位与 \\ 按位或 ~expr 按位非 ^ 按位异或 二、按位运算符的用法 （一） 按位与 按位与在 Dart 中用 \"&\" 表示，\"&\" 两边写整数，俩二进制相同位数都是 1 的话，那个相同位的结果就是 1 ，否则为 0 ，比如说 22 的二进制是 10110，15 的二进制是 1111，不够的补 0，所以 20 & 15 的运算如下(Dart int 好像没有说占多少字节的，所以这里用 32 位的代替，下同)： 计算结果为 110，即十进制的 6， var value = 22 & 15; print('value = $value'); 复制代码 （二） 按位或 按位或在 Dart 中用 \"|\" 表示，\"|\" 两边写整数，俩二进制相同位只要有一个是 1，那个相同位的结果是 1，当相同位的两个都是 0 时，那个相同位的结果才是 0 ，又拿 22 和 15 来说， 22 的二进制是 10110，15 的二进制是 1111，不够的补 0，所以 20 | 15 的运算如下： 计算结果为 11111，即十进制的 31， var value = 22 | 15; print('value = $value'); 复制代码 （三） 按位非 按位非在 Dart 中用 \"~expr\" 表示，\"~\" 右边写整数，把整数转为 2 进制，2 进制中 0 的结果是 1 ，1 的结果是 0，以 31 为例吧，31 的二进制是 11111，~31 的运算如下： 计算结果为 11111111 11111111 11111111 11100000，即十进制的 -32，用计算器验证一下吧， var value = ~31; print('value = $value'); 复制代码 （四） 按位异或 按位异或在 Dart 中用 \"^\" 表示，\"^\" 左边和右边写整数，把整数转为 2 进制，俩 2 进制中相同位的只有一个是 1 的结果才是 1 ，俩 2 进制中相同位都是 1 或 都是 0 的结果是 0，拿 22 和 15 来说， 22 的二进制是 10110，15 的二进制是 1111，22 ^ 15 的运算如下： 计算结果为 11001，即十进制的 25， var value = 22 ^ 15; print('value = $value'); 复制代码 "},"blog/Dart/Dart_relation_compute.html":{"url":"blog/Dart/Dart_relation_compute.html","title":"Dart 关系运算符","keywords":"","body":"Dart 关系运算符 cekiasoo 2018年09月22日 16:05 · 阅读 2116 一、什么是关系运算符 关系运算符就是比较两个数的大小的，Dart 中的关系运算符有 运算符 解释 == 等于 > 大于 >= 大于或等于 小于 小于或等于 != 不等于 二、关系运算符的用法 (一) 等于 等于在 Dart 用 \"==\" 表示, 第一个数和第二个数相同就返回 true, 否则返回 false, int a = 10; int b = 11; print(a == b); 复制代码 int a = 10; int b = 10; print(a == b); 复制代码 (二) 大于 大于在 Dart 用 \">\" 表示，第一个数比第二个数大就返回 true, 否则返回 false, int a = 8; int b = 6; print(a > b); 复制代码 int a = 8; int b = 10; print(a > b); 复制代码 (三) 大于或等于 大于或等于在 Dart 用 \">=\" 表示，第一个数大于或等于第二个数就返回 true, 否则返回 false, int a = 22; int b = 3; print(a >= b); 复制代码 int a = 22; int b = 22; print(a >= b); 复制代码 int a = 22; int b = 25; print(a >= b); 复制代码 (四) 小于 小于在 Dart 用 \" int a = 88; int b = 89; print(a int a = 88; int b = 87; print(a (五) 小于或等于 小于或等于在 Dart 用 \" int a = 36; int b = 37; print(a int a = 36; int b = 36; print(a int a = 36; int b = 35; print(a (六) 不等于 不等于在 Dart 中用 \"!=\" 表示，第一个数和第二个数不相同返回 true, 相同返回 false, int a = 666; int b = 999; print(a != b); 复制代码 int a = 666; int b = 666; print(a != b); 复制代码 "},"blog/Dart/dart_final_const.html":{"url":"blog/Dart/dart_final_const.html","title":"Dart 常量","keywords":"","body":"Dart 常量 cekiasoo 2018年09月22日 15:55 · 阅读 3858 一、什么是常量 常量就是在运行期间不会被改变的数据，比如说有个存储单元这一秒存的数是 1，永远不可能会被改成 2； 二、如何定义常量 定义常量有两种方式，一种是用 final, 另一种是用 const, （一）用 final 定义常量 final 数据类型 常量名 = 值; /** * 常量 */ void main() { // final 定义常量 final int age = 18; } 复制代码 数据类型也可以省略 /** * 常量 */ void main() { // final 定义常量 final age = 18; } 复制代码 赋值后就不能改了，尝试修改会有警告， 强行运行就会报错； （二）用 const 定义常量 const 数据类型 常量名 = 值; /** * 常量 */ void main() { // const 定义常量 const String name = 'xiaoming'; } 复制代码 const 的数据类型也是可以省略的， /** * 常量 */ void main() { // const 定义常量 const name = 'xiaoming'; } 复制代码 同样 const 常量赋值后就不能改了， 运行也是会报错的， （三）final 和 const 的区别 看起来 final 和 const 是差不多的，其实是有区别的，final 可以不用先赋值，const 声明时必须赋值，不然会报错， final 的 nickname 声明时没赋值不会报错 const 的 nickname 声明时没赋值直接红线报错了 "},"blog/Dart/dart_explain.html":{"url":"blog/Dart/dart_explain.html","title":"Dart 注释","keywords":"","body":"Dart 注释 cekiasoo 2018年09月22日 15:52 · 阅读 240 一、什么是注释 注释呢就是用于解释和说明代码的，适当地注释代码可增强代码的可读性的，Dart 也是支持注释的，注释一般是不会影响到代码的执行的，除了 HTML 的条件注释，这里说的是 Dart ，注释自然对 Dart 的代码执行是没影响的。 二、单行注释 单行注释就是只有一行的注释，单行注释比较方便，以 \"//\" 开头，\"//\" 后面写注释内容。 三、多行注释 多行注释是可以跨越多行的，多行文档注释是以 \"/*\" 开头的， 接着写注释内容 最后 \"*/\" 结束 多行注释写成一行也是可以的 有些人喜欢这种风格的多行注释，每行注释前面加个 * 四、文档注释 文档注释是用于代码文档编写的，Dart SDK 有个 dartdoc 工具，用于生成文档的，具体可以看这里 Dart SDK 工具生成文档 文档注释也有分单行和多行的； （一）单行文档注释 单行文档注释是以 \"///\" 开头的，三个 ‘'/\" ，后面写内容 （二）多行文档注释 多行文档注释是以 \"/**\" 开头的，后面写注释内容 最后 \"*/\" 结束 "},"blog/Dart/dart_type.html":{"url":"blog/Dart/dart_type.html","title":"Dart 数据类型","keywords":"","body":"Dart 数据类型 cekiasoo 2018年09月22日 15:57 · 阅读 4195 一、Dart 有哪些数据类型 Dart 内置的数据类型有描述数字的 int 和 double，字符串的 String 类型，布尔 bool 类型，列表 List 类型，具有映射关系的 Map 类型。 二、数字类型 数字类型有 int 和 double 还有 num， （一）int 类型 int 是 整型，即整数，如 1， 2， 10， 20 等, 在上两篇文章讲了 Dart 变量 和 Dart 常量 ，还没看的可以去看看，现在对于 int 类型的数据定义应该挺简单的了， int number = 10; 复制代码 或 var number = 10; 复制代码 （二）double 类型 double 是浮点型，即包含小数的，如 0.1，0.2，10.1， 10.2 等, double number = 10.1; 复制代码 或 var number = 10.1; 复制代码 double 是包含小数类型的，如果赋予整数会报错 （三）num 类型 num 可以是整数或浮点数的类型，毕竟 num 是 int 和 double 的父类， 再来看一下 num 源码中的注释是怎么说的，嗯，整数或浮点数 num 是可以这样定义的 num number = 1; 复制代码 或浮点型 num number = 1.01; 复制代码 num 既然可以是整型或浮点型，那么 num 类型的变量赋了整型的数也可以改为浮点型的数， num number = 1; num number = 1.01; 复制代码 这样做是没问题的， 运行也是没问题的 三、字符串类型 字符串类型在 Dart 中是用 String 表示，数据用单引号或双引号扩起来， String name = 'xiaoming'; 复制代码 或 String name = \"xiaoming\"; 复制代码 也可以用 var var name = 'xiaoming'; 复制代码 字符串还有一种是多行字符串用 '''（三个单引号） 或 \"\"\"（三个双引号） 括起来，可以多行而不报错， String description = ''' 这 是 描述'''; 复制代码 或 String description = \"\"\" 这 是 描述\"\"\"; 复制代码 输出到控制台也是多行的， 字符串类型还可以用 $ 和其他类型拼接， int a = 1; String str = \"a = $a\"; print(str); 复制代码 四、布尔类型 布尔类型比较简单，它的值只有 true 或 false，在 Dart 中用 bool 表示， bool error = false; 复制代码 或 bool error = true; 复制代码 五、列表类型 列表简单来说就是存放着排成一列的数据，可以理解为一个存放数据的容器，列表中的每个数据称为元素，在 Dart 中用 List 表示，数据用 \"[]\" 括起来，元素之间用 \",\" 隔开，如果不指定 List 中存放的数据类型的话是可以存放任意类型的数据的， List list = ['a', 'b', 'c', 1, 2, 3, true, false]; 复制代码 列表可以直接用 print 输出到控制台， 如果想要获取列表中的某个元素，可以用 列表名[元素在列表中的位置] 获取，列表元素的第一个位置是从 0 开始的，所以想要获取第一个位置的元素就是 List list = ['a', 'b', 'c']; var element = list[0]; 复制代码 获取元素时，位置不能大于列表存放元素的个数 - 1，也不能小于 0，即位置的取值范围是 [0, 元素的个数 - 1]，全闭区间，超过列表存放元素的个数 - 1 或小于 0 是会报错的，比如列表存放着 3 个数据，取的时候用 list[5] ，5 比 3-1 大，会报错， 列表的元素个数可以用 列表名.length 获取 int length = list.length; 复制代码 如果只想存一种数据类型的数据，那要借助泛型， List list3 = ['a', 'b', 'c']; 复制代码 添加别的元素就会报错， 六、Map 类型 Map 就是存放具有键值对关系的数据的容器，在 Dart 中就是用 Map 表示，键是唯一的，值可以不相同，比如人的身份证，身份证号是唯一的，名字可以相同，如果两个人的身份证号相同那就乱了，Map 的数据是用 \"{}\" 括起来，里面的数据用 \"键 : 值\", 数据之间用 \",\" 隔开，如果没指定数据类型，键值的数据类型可以是任意的， Map map = {'Apple' : '苹果', 'Banana' : '香蕉', 'Peach' : '桃子', 1 : '1', true : 0}; 复制代码 Map 也是可以直接用 print 输出的， 想获取某个键的值就用 \"Map的名['键的名']\" Map map = {'Apple' : '苹果', 'Banana' : '香蕉', 'Peach' : '桃子'}; String value = map['Apple']; print(value); 复制代码 Map 的键和值的数据类型也可以是指定的， Map map = {1 : 'a', 2 : 'b', 3 : 'c'}; 复制代码 存放其他的类型是会报错的， Map map2 = {1 : 'a', 2 : 'b', 3 : 'c', 4 : 'd', '5' : 'e'}; 复制代码 "},"blog/Dart/dart_math_compute.html":{"url":"blog/Dart/dart_math_compute.html","title":"Dart 算术运算符","keywords":"","body":"Dart 算术运算符 cekiasoo 2018年09月22日 16:02 · 阅读 6389 一、什么是算术运算符 算术运算符就是加减乘除等四则运算操作的符号，如 + 、-、*、/ 等，Dart 中的算术运算符有 运算符 解释 + 加法 - 减法 * 乘法 / 除法 % 求余 -expr 取负 ++ 自增 1 -- 自减 1 ~/ 取整除法 二、算术运算符的用法 （一） 加法 用法： var 值 = 数1 + 数2; int a = 10; int b = 12; int c = a + b; print('$a + $b = $c'); 复制代码 （二） 减法 用法： var 值 = 数1 - 数2; int a = 20; int b = 12; int c = a - b; print('$a - $b = $c'); 复制代码 （三） 乘法 用法： var 值 = 数1 * 数2; int a = 3; int b = 7; int c = a * b; print('$a * $b = $c'); 复制代码 （四） 除法 用法： var 值 = 数1 / 数2; 对于除法返回的值是 double 类型的，毕竟有可能是含小数的， int a = 3; int b = 7; double c = a / b; print('$a / $b = $c'); 复制代码 （五） 求余 用法： var 值 = 数1 % 数2; int a = 9; int b = 6; int c = a % b; print('$a % $b = $c'); 复制代码 （六）取负 取负就是一个数如果是正的取负就把这个数变负数，如果一个数是负的就把这个数变正数， 用法： var 值 = -数; int a = 10; int b = -a; print('b = $b'); 复制代码 （七） 自增 1 自增 1 就是在原来的数的基础上加一，自增有分前自增和后自增，单独使用的时候没分别，在不是单独使用的时候就有区别了， 后自增的用法： var num = 10; num++; print('num = $num'); 复制代码 前自增的用法： var num = 5; ++num; print('num = $num'); 复制代码 比较下前自增和后自增的区别吧， var num = 5; var value = num++; print('num = $num, value = $value'); 复制代码 后自增是先取值再增 1 ，这里 num 是先把值赋给 value，num 再自增 1，所以 num 是 6，value 是 5， var num = 5; var value = ++num; print('num = $num, value = $value'); 复制代码 前自增是先增 1 再取值，这里 num 是先自增 1，再把 num 值赋给 value ，所以 num 是 6，value 也是 6， （八） 自减 1 自增 1 就是在原来的数的基础上减一，和自增一样，也有分前自减和后自减，单独使用的时候没分别，在不是单独使用的时候有区别， 后自减的用法： var num = 10; num--; print('num = $num'); 复制代码 前自减的用法： var num = 5; --num; print('num = $num'); 复制代码 前自减与后自减的区别 var num = 5; var value = num--; print('num = $num, value = $value'); 复制代码 var num = 5; var value = --num; print('num = $num, value = $value'); 复制代码 和自增一样，前自减是先减 1 再取值，后自减是先取值再减 1 ； （九） 取整除法 取整除法就是两个数相除结果取整数部分，比如 10 除以 3 结果本来是 3.333... , 取整的结果就是 3 ， int a = 10; int b = 3; int c = a ~/ b; print('$a ~/ $b = $c'); "},"blog/Dart/control_struct.html":{"url":"blog/Dart/control_struct.html","title":"Dart 控制流语句","keywords":"","body":"Dart学习-控制流语句 你需要一台永动机关注IP属地: 福建 你可以使用以下任一项来控制Dart代码的流程: if 和 else for循环 while 和 do-while 循环 break 和continue switch 和case assert 你也可以使用try-catch和throw来语句 if 和 else dart支持带有可选else语句的if语句，如下一个示例所示。 if (isRaining()) { you.bringRainCoat(); } else if (isSnowing()) { you.wearJacket(); } else { car.putTopDown(); } 与JavaScript不同，条件必须使用布尔值，而不是其他值。 For循环 你可以使用循环的标准迭代。例如: var message = StringBuffer('Dart is fun'); for (var i = 0; i for循环中的闭包捕获索引的值，避免了js中常见的陷阱。例如: var callbacks = []; for (var i = 0; i print(i)); } callbacks.forEach((c) => c()); 如预期的，输出是0，然后是1。相比之下，这个例子在js打印2，然后打印2。 如果要迭代的对象是可迭代的，则可以使用forEach()方法。如果不需要知道当前迭代计数器，使用forEach()是一个很好的选择: candidates.forEach((candidate) => candidate.interview()); List和Set等可迭代类也支持迭代的形式: var collection = [0, 1, 2]; for (var x in collection) { print(x); // 0 1 2 } While 和 do-while while循环会在循环之前判断条件是否满足,满足继续循环: while (!isDone()) { doSomething(); } do-while会在循环之后判断条件是否满足,满足继续循环： do { printLine(); } while (!atEndOfPage()); Break 和 continue 使用break停止循环: while (true) { if (shutDownRequested()) break; processIncomingRequests(); } 使用continue跳到下一个循环迭代: for (int i = 0; i 如果使用List或Set之类的迭代类，你可以用不同的方式编写该示例： candidates .where((c) => c.yearsExperience >= 5) .forEach((c) => c.interview()); Switch 和 case Dart中的switch语句使用==，比较整数、字符串或编译时常量。比较的对象必须都是同一个类的实例(而不是其任何子类型的实例)，并且该类不能重写==。 注: Dart中的Switch语句是针对有限的情况，例如interpreters或scanners。 通常，每个非空case子句以break语句结尾。结束非空case子句的其他方法有continue、throw或return语句。 当没有case子句匹配时，使用default子句执行代码: var command = 'OPEN'; switch (command) { case 'CLOSED': executeClosed(); break; case 'PENDING': executePending(); break; case 'APPROVED': executeApproved(); break; case 'DENIED': executeDenied(); break; case 'OPEN': executeOpen(); break; default: executeUnknown(); } 以下示例省略了case子句中的break语句，因此发生错误: var command = 'OPEN'; switch (command) { case 'OPEN': executeOpen(); // 错误: 缺失 break case 'CLOSED': executeClosed(); break; } 然而，Dart确实支持空的case子句，并允许使用从一个case到另一个case的贯穿形式： var command = 'CLOSED'; switch (command) { case 'CLOSED': // Empty case 可以通过 case 'NOW_CLOSED': // CLOSED 和 NOW_CLOSED 都可以运行 executeNowClosed(); break; } 如果你真的想要这种贯穿方式，你可以使用continue语句和标签: var command = 'CLOSED'; switch (command) { case 'CLOSED': executeClosed(); continue nowClosed; // Continues 执行nowClosed 标签 . nowClosed://这就是标签 case 'NOW_CLOSED': // CLOSED 和 NOW_CLOSED 都可以运行 executeNowClosed(); break; } case子句可以有局部变量，这些变量仅在该子句的范围内可见。 Assert 如果布尔条件为false，则使用assert语句中断正常执行。在本教程中，你可以找到assert语句的示例。以下是更多: // 确保变量具有非空值。 assert(text != null); // 确保该值小于100。 assert(number 注：Assert语句在生产代码中不起作用；它仅仅用于开发。Flutter在debug模式下asserts可用。默认情况下，dartdevc等仅开发工具通常支持asserts。一些工具，如dart和dart 2js，通过命令行标志支持asserts: --enable-asserts。 若要将消息附加到assert，请添加字符串作为第二个参数。 assert(urlString.startsWith('https'), 'URL ($urlString) should start with \"https\".'); 在assert语句后面的括号中，你可以加入任何表示布尔值或者函数的表达式。如果表达式的值或者函数返回值true，则assert语句成功并继续执行代码。如果值为false，则assert语句失败并抛出一个异常。 PS:本文整理自官方文档，若有发现问题请致邮 caoyanglee92@gmail.com "},"blog/Dart/dart_give_value.html":{"url":"blog/Dart/dart_give_value.html","title":"Dart 赋值运算符","keywords":"","body":"Dart 赋值运算符 cekiasoo 2018年09月22日 16:09 · 阅读 440 一、什么是赋值运算符 赋值运算符就是把右边的值赋给左边，比如之前见过的 \"=\", 还有一些是运算和赋值同时进行的符号，Dart 中赋值运算符有 运算符 解释 = 赋值 += 加法运算并赋值 -= 减法运算并赋值 *= 乘法运算并赋值 /= 除法运算并赋值 %= 求余运算并赋值 ~/= 取整运算并赋值 左移运算并赋值 >>= 右移运算并赋值 &= 按位与运算并赋值 = 按位或运算并赋值 ^= 按位异或运算并赋值 二、赋值运算符的用法 （一） 赋值 赋值就是把右边的值赋给左边，在 Dart 中用 \"=\" 表示，这不是等号，等号是 \"==\", var num = 5; print('a = $num'); 复制代码 （二） 加法运算并赋值 加法运算并赋值就是先用左边的值和右边的值做加法运算然后把结果赋给左边，在 Dart 中用 \"+=\" 表示， var num = 8; num += 2; print('num = $num'); 复制代码 把 \"+=\" 运算拆分开来相当于 var num = 8; num = num + 2; print('num = $num'); 复制代码 （三） 减法运算并赋值 减法运算并赋值就是先用左边的值减去右边的值然后把结果赋给左边，在 Dart 中用 \"-=\" 表示， var num = 8; num -= 2; print('num = $num'); 复制代码 把 \"-=\" 运算拆分开来相当于 var num = 8; num = num - 2; print('num = $num'); 复制代码 （三） 乘法运算并赋值 乘法运算并赋值就是先用左边的值和右边的值做乘法运算然后把结果赋给左边，在 Dart 中用 \"*=\" 表示， var num = 8; num *= 2; print('num = $num'); 复制代码 把 \"*=\" 运算拆分开来相当于 var num = 8; num = num * 2; print('num = $num'); 复制代码 （四） 除法运算并赋值 除法运算并赋值就是先用左边的值除以右边的值然后把结果赋给左边，在 Dart 中用 \"/=\" 表示， var num = 8; num /= 2.2; print('num = $num'); 复制代码 把 \"/=\" 运算拆分开来相当于 var num = 8; num = num / 2.2; print('num = $num'); 复制代码 （五） 求余运算并赋值 求余运算并赋值就是先用左边的值对右边的值进行求余运算然后把结果赋给左边，在 Dart 中用 \"%=\" 表示， var num = 8; num %= 3; print('num = $num'); 复制代码 把 \"%=\" 运算拆分开来相当于 var num = 8; num = num % 3; print('num = $num'); 复制代码 （六） 取整运算并赋值 取整运算并赋值就是先用左边的值除以右边的值取整数然后把结果赋给左边，在 Dart 中用 \"~/=\" 表示， var num = 8; num ~/= 2.2; print('num = $num'); 复制代码 把 \"~/=\" 运算拆分开来相当于 var num = 8; num = num ~/ 2.2; print('num = $num'); 复制代码 （七） 左移运算并赋值 左移运算并赋值就是先用左边的值的二进制位向左移动右边值个位，得到的结果赋给左边，在 Dart 中用 \" var num = 8; num 把 \" var num = 8; num = num （八） 右移运算并赋值 右移运算并赋值就是先用左边的值的二进制位向右移动右边值个位，得到的结果赋给左边，在 Dart 中用 \">>=\" 表示， var num = 8; num >>= 2; print('num = $num'); 复制代码 把 \">>=\" 运算拆分开来相当于 var num = 8; num = num >> 2; print('num = $num'); 复制代码 （九） 按位与运算并赋值 按位与运算并赋值就是先用左边的值的二进制对右边的值的二进制进行按位与运算然后把结果赋给左边，在 Dart 中用 \"&=\" 表示， var num = 5; num &= 22; print('num = $num'); 复制代码 把 \"&=\" 运算拆分开来相当于 var num = 5; num = num & 22; print('num = $num'); 复制代码 （十） 按位或运算并赋值 按位或运算并赋值就是先用左边的值的二进制对右边的值的二进制进行按位或运算然后把结果赋给左边，在 Dart 中用 \"|=\" 表示， var num = 5; num |= 22; print('num = $num'); 复制代码 把 \"|=\" 运算拆分开来相当于 var num = 5; num = num | 22; print('num = $num'); 复制代码 （十一） 按位异或运算并赋值 按位异或运算并赋值就是先用左边的值的二进制对右边的值的二进制进行按位异或运算然后把结果赋给左边，在 Dart 中用 \"^=\" 表示， var num = 8; num ^= 2; print('num = $num'); 复制代码 把 \"^=\" 运算拆分开来相当于 var num = 8; num = num ^ 2; print('num = $num'); 复制代码 "},"blog/Dart/dart_key_words.html":{"url":"blog/Dart/dart_key_words.html","title":"Dart 关键字","keywords":"","body":"Dart 关键字 cekiasoo 2018年09月22日 15:53 · 阅读 184 一、什么是关键字 关键字就是保留字，比如变量、类型等的名字，通常不能作为标识符使用； 二、关键字有哪些 每种语言的关键字会有所不同，Dart 语言的关键字如下： abstract dynamic implements show as else import static assert enum in super async export interface switch await external is sync break extends library this case factory mixin throw catch false new true class final null try const finally on typedef continue for operator var covariant Function part void default get rethrow while deferred hide return with do if set yield "},"blog/Dart/dart_bit_move.html":{"url":"blog/Dart/dart_bit_move.html","title":"Dart 移位运算符","keywords":"","body":"Dart 移位运算符 cekiasoo 2018年09月22日 16:09 · 阅读 2405 一、什么是移位运算符 移位运算符也是对整数的二进制进行操作的，Dart 中移位操作符有 运算符 解释 左移 >> 右移 二、移位运算符的用法 （一） 左移 左移就是二进制位向左移动，低位的补 0 ，如果有最高位的话移出的就不要，不过 Dart 的 int 应该没最高位，但是移过多位会出现 Exhausted heap space，拿 9 左移 3 位来说，9 的二进制是 1001，左移 3 位是 1001000，即十进制的 72， int value = 9 （二） 右移 右移自然就是二进制位向右移动了，低位移出了的就不要了，高位正数补 0，负数补 1，还是拿 9 右移 3 位来说，9 的二进制是 1001，右移 3 位 001 被移了出去，就不要了，剩 1，所以结果是 1，十进制也是 1， int value = 9 >> 3; print('value = $value'); 复制代码 "},"blog/Dart/dart_three_var_compute.html":{"url":"blog/Dart/dart_three_var_compute.html","title":"Dart 三元运算符","keywords":"","body":"Dart 三元运算符 cekiasoo 2018年09月22日 16:08 · 阅读 6354 一、三元运算符的用法 三元运算符的用法为： bool-expr ? value1 : value2; 如果 bool-expr 为 true 就返回 value1, 如果 bool-expr 为 false 就返回 value2，比如说如果他的另一半是女的那他是正常的，否则他就是 Gay (此处应有去污粉)， bool isGirl = true; String hobby = isGirl ? 'Normal' : 'Gay'; print(hobby); 复制代码 "},"blog/Dart/dart_var.html":{"url":"blog/Dart/dart_var.html","title":"Dart 变量","keywords":"","body":"Dart 变量 cekiasoo 2018年09月22日 15:54 · 阅读 174 一、什么是变量 变量就是在运行期间随时会被改变的数据，比如说有个存储单元这一秒存的数是 1，下一秒可能会被改成 2； 二、如何定义变量 变量是这样定义的： 数据类型 变量名; 如 int age; int 是数据类型（整形），age 是变量名， /** * 变量 */ void main() { // int 型变量 int age; age = 1; print(age); // 被改变了 age = 2; print(age); } 运行结果是 变量的数据类型也可以用 var，即 variable, var 变量名; 上面的 int age; 可以改为 var age; /** * 变量 */ void main() { // int 型变量 var age; age = 1; print(age); // 被改变了 age = 2; print(age); } 变量可以给个初始值， var age; age = 1; 可以改为 var age = 1; "},"blog/ubuntu/Flameshot.html":{"url":"blog/ubuntu/Flameshot.html","title":"截图之Flameshot","keywords":"","body":"在 Linux 中使用 Flameshot 获取屏幕截图并编辑 功能概述 注释 (高亮、标示、添加文本、框选) 图片模糊 图片裁剪 上传到 Imgur 用另一个应用打开截图 如果你需要的是一个能够用于标注、模糊、上传到 imgur 的新式截图工具，那么 Flameshot 是一个好的选择。 安装截图工具Flameshot 如果你用的是 Ubuntu，那么只需要在 Ubuntu 软件中心上搜索，就可以找到 Flameshot 进而完成安装了 使用终端来安装，可以执行以下命令 sudo apt install flameshot 如果你在安装过程中遇到问题，可以按照官方的安装说明进行操作 安装完成后，你还需要进行配置。尽管可以通过搜索来随时启动 Flameshot，但如果想使用 快捷键 触发启动，则需要指定对应的键盘快捷键。 配置截图快捷键 进入系统设置中的“键盘设置” 页面中会列出所有现有的键盘快捷键，拉到底部就会看见一个 “+” 按钮 点击 “+” 按钮添加自定义快捷键并输入以下两个字段： “名称”： 任意名称均可。 “命令”： /usr/bin/flameshot gui 最后将这个快捷操作绑定到 Ctrl+Q 键上，可能会提示与系统的截图功能相冲突，但可以忽略掉这个警告。 配置之后，你的自定义快捷键页面大概会是以下这样： "},"blog/prometheus/grafana_prometheus_metrics.html":{"url":"blog/prometheus/grafana_prometheus_metrics.html","title":"监控之prometheus","keywords":"","body":"利用granfana、prometheus、node_exporter示例监控部署 下载prometheus、grafana、node_exporter程序。 wget http://file.ethlink.cn/tools/prometheus.tar.gz wget http://file.ethlink.cn/tools/node_export.tar.gz wget http://file.ethlink.cn/tools/grafana_7.3.4_amd64.deb 解压tar包，安装grafana tar -zxvf prometheus.tar.gz tar -zxvf node_export.tar.gz dpkg -i grafana_7.3.4_amd64.deb 配置prometheus `cd prometheus-2.23.0.linux-amd64` `vim prometheus.yml` ![Img](./FILES/grafana_prometheus_metrics.md/img-20220912101754.png) 填写要监控的主机的IP，端口都是9100 。node_exporter服务端口就是9100。 启动prometheus vim /etc/systemd/system/prometheus.service [Unit] Description=Prometheus Monitoring System Documentation=Prometheus Monitoring System [Service] ExecStart=/home/ubuntu22/tools/prometheus-2.38.0.linux-amd64/prometheus --config.file=/home/ubuntu22/tools/prometheus-2.38.0.linux-amd64/prometheus.yml --web.listen-address=:9090 Restart=on-failure [Install] WantedBy=multi-user.target 加载、开机自启动、启动服务、查看服务、重启服务、停止服务 sudo /bin/systemctl daemon-reload sudo systemctl start prometheus sudo systemctl status prometheus sudo systemctl restart prometheus sudo systemctl stop prometheus 配置node `vim /etc/systemd/system/node_exporter.service` 写入如下内容： [Unit] Description=node_exporter Documentation=https://github.com/prometheus/node_exporter [Service] ExecStart=/home/wangchenxi/usr/node_exporter-1.4.0-rc.0.linux-amd64/node_exporter --collector.systemd --collector.processes Restart=on-failure [Install] WantedBy=multi-user.target 执行开机自启动服务、启动服务、查看状态 sudo systemctl daemon-reload sudo systemctl enable node_exporter.service sudo systemctl start node_exporter.service sudo systemctl status node_exporter.service 配置webui 打开主机地址+3000端口。 例如：主机IP为192.168.22.23 浏览器输入以下地址： http://192.168.22.23:3000 默认用户为 admin admin 登陆后修改密码 修改完密码进入主页。准备配置数据源 点击Add data source 选择prometheus 填入主机的IP,端口号为9090 点击保存并测试（save&test） 导入模板配置 搭建其他服务的监控 1. 例如mysql、nginx这些都有对应的，监控模板和对应的node服务，可以自行查找攻略； 2. 如果要监控自主开发的服务或系统，需要自己实现对应的prometheus_client，然后在prometheus中配置添加对应节点。 ProQL 如果要自己定义展示模板，可以学习prometheus的query language，简称ProQL。 "},"blog/other/virtualbox_androidx86.html":{"url":"blog/other/virtualbox_androidx86.html","title":"virtualbox安装androidx86","keywords":"","body":" VirtualBox中安装Android-x86详解 1.下载安装VirtualBox 官网：http://www.virtualbox.org/wiki/Downloads 2.下载Android-x86 官网：http://www.android-x86.org/download 这里我们下载5.1稳定版 3.新建VirtualBox虚拟机，并进行相关配置 创建好之后如下： 右键->设置->系统， 修改指点设备为PS/2鼠标 显示：显存设置为最大，并启用3D加速 网络：修改为桥接网卡（默认的NAT方式主机无法访问虚拟机） 4.安装Android-x86 双击打开上面创建的虚拟机，加载android-x86-5.1-rc1.iso镜像，如下 前3个都是光盘启动Android-x86系统，无需安装。我们选择最后一项，回车开始安装，如下 接着选择第二项，创建新分区，如下 选择NO，回车 选择NEW->Primary，默认大小，回车，如下 选择Bootable作为启动分区，回车，如下 选择Write回车，然后填写yes并回车，把上面的操作全部写入磁盘，如下 然后Quit，回到安装界面，选择第一项sda1，回车 分区格式我们这里选择ext3，官方推荐ntfs，但实际测试选择ntfs系统无法启动。 Yes GRUB，即启动系统时的引导界面，Yes EFI GRUB2，选择Skip Yes 正在写入： 安装成功，Reboot，重启 这时还是会加载ISO进入系统安装界面，因为我们还没移除虚拟盘，点击移除虚拟盘，然后控制->重启 顺利进入GRUB，选择第一项启动Android-x86 选择简体中文，然后依次点击屏幕的ABCD四个位置，这样可以跳过设置向导，如下 然后进入桌面，如下 下面我们就可以在PC上随意调试安卓程序了~ 在安装Android-x86后，由于nVidia显卡驱动的原因启动过程中可能会卡住无法进入图形界面。此时在需要在启动参数中添加nomodeset选项来禁用显卡。其他Linux系统中遇到同样的问题也可以使用此方法解决。 常见问题 产生原因 The newest kernels have moved the video mode setting into the kernel. So all the programming of the hardware specific clock rates and registers on the video card happen in the kernel rather than in the X driver when the X server starts.. This makes it possible to have high resolution nice looking splash (boot) screens and flicker free transitions from boot splash to login screen. Unfortunately, on some cards this doesnt work properly and you end up with a black screen. Adding the nomodeset parameter instructs the kernel to not load video drivers and use BIOS modes instead until X is loaded. 某些显卡下Linux内核无法正常工作导致黑屏。 解决方法 开机后在grub界面选择第二项Debug mode，输入 mount –o remount,rw /mnt 再输入 vi /mnt/grub/menu.lst 在第七行的root前加入quiet nomodeset，修改后内容如下： ... title Android-x86 8.1-r5 kernel /android-8. 1-r5/kernel quiet nomodeset root=/dev/ram0 SRC=/android-8. 1-r5 initrd /android-8. 1-r5/ initrd. img ... 按ESC退出编辑，并输入:wq保存退出。 重启后即可进入图形界面。 "},"blog/other/githubPages.html":{"url":"blog/other/githubPages.html","title":"github Page","keywords":"","body":"github pages 搭建网站 GitHub Pages 是一个静态站点托管服务。 可以展示静态网站,打开此功能. 可以通过https://用户名.github.io/项目名访问此项目的静态页面,首页为index.html 此类项目可以创建多个. 还可以创建 用户名.github.io 的项目名, 访问https://用户名.github.io 即可 但此类github pages只能创建一个,不能像上面的创建多个. 可以使用 hexo, hugo, gitbook, mkdocs 等快速构建你的静态页面网站. "},"blog/other/plantUML.html":{"url":"blog/other/plantUML.html","title":"plantUML工具","keywords":"","body":"plantUML 16.plantuml Star 7kFork 697 Watch 146 从文本描述生成 UML 图的工具。该项目可根据简单的文字描述画出 UML 图，支持顺序图、用例图、时序图等，除此之外还支持架构图、甘特图、思维导图、实体关系图等非 UML 图。支持在线、命令行、桌面应用等多种使用方式，可根据情况自行选择。 java -jar plantuml.jar 文本文件 将得到一个同名的 png 文件 本地使用参照官方文档本地安装配置 Vscode有相应的插件 是一个梳理流程的好工具。 "},"blog/other/code2flow.html":{"url":"blog/other/code2flow.html","title":"code2flowe工具","keywords":"","body":"code2flow 34.code2flow Star 2.7kFork 220 Watch 68 为动态语言生成调用图的工具。可根据源码文件生成漂亮的调用图的命令行工具，支持 Python、JavaScript、Ruby 等动态语言。 # 安装 pip3 install code2flow # 使用 code2flow 文件 "},"blog/other/scrcpy.html":{"url":"blog/other/scrcpy.html","title":"scrcpy工具","keywords":"","body":"2.scrcpy Star 7.2wFork 7.7k Watch 1.1k 一款可以用电脑显示并控制 Android 手机的开源工具。连接方便使用方便，手机无需 root、无需安装任何应用。支持 USB、Wi-Fi 两种方式连接，支持 Windows、macOS、Linux 三种操作系统。注意电脑端需要安装 adb 工具 "},"blog/other/key_action.html":{"url":"blog/other/key_action.html","title":"按键查看工具","keywords":"","body":"按键随时查看 工具carnac 用于展示键盘按键操作的工具。这是一款能够在桌面实时显示键盘操作记录的工具，多用于演示应用、录制教程等场景，适用于 Windows 7 及以上的操作系统。 "},"blog/devops/nginx专题.html":{"url":"blog/devops/nginx专题.html","title":"nginx配置","keywords":"","body":"nginx专题 nginx七大应用场景 web服务器 请给出，nginx作为web服务器的常见配置conf文件，要求可以直接使用。 server { listen 80; server_name example.com; # 根目录 root /var/www/example.com; # 索引文件 index index.html index.php; # SSL 证书 ssl_certificate /path/to/certificate.crt; ssl_certificate_key /path/to/certificate.key; # HTTP 标头安全（HSTS） add_header Strict-Transport-Security \"max-age=31536000\"; # 缓存 location /static { expires 30d; } # Gzip 压缩 gzip on; gzip_types text/plain text/css text/javascript application/javascript application/x-javascript; # keepalive 连接 keepalive_timeout 65; # FastCGI 配置 location ~ \\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } # 错误页面 error_page 404 /404.html; error_page 500 /500.html; # 日志记录 access_log /var/log/nginx/example.com-access.log; error_log /var/log/nginx/example.com-error.log; } 反向代理 负载均衡 请给出，nginx作为web服务器的常见配置conf文件，要求可以直接使用。 server { listen 80; server_name example.com; # 将请求转发到后端服务器 location / { proxy_pass http://backend-server:8080; } # SSL 证书 ssl_certificate /path/to/certificate.crt; ssl_certificate_key /path/to/certificate.key; # HTTP 标头安全（HSTS） add_header Strict-Transport-Security \"max-age=31536000\"; # keepalive 连接 keepalive_timeout 65; # 负载均衡 upstream backend-servers { # 负载均衡策略 ip_hash; server backend-server1:8080; server backend-server2:8080; } # 将请求负载均衡到后端服务器 location /api { proxy_pass http://backend-servers; proxy_set_header Host $host proxy_set_header X-Real-IP $remote_addr } # 日志记录 access_log /var/log/nginx/example.com-access.log; error_log /var/log/nginx/example.com-error.log; } URL重定向 防盗链 server { listen 80; server_name example.com; # 允许来自自身网站的请求 location / { allow all; } # 阻止来自其他网站的请求 location / { valid_referers none blocked server_names example.com *.example.com; if (invalid_referer) { return 403; } } } 根据变量重定向 server { listen 80; server_name example.com; # 将包含 \"ipad\" 的 user-agent 的请求重定向到 test.com location / { if ($http_user_agent ~* \"ipad\") { return 301 https://test.com$request_uri; } # 对于其他请求，正常处理 ... } } 也可以根据请求路径转发到响应的服务 nginx匹配路径/ nginx配置图形化界面 nginx proxy manager 官网地址： https://nginxproxymanager.com/guide/ Create a docker-compose.yml file similar to this: version: '3.8' services: app: image: 'jc21/nginx-proxy-manager:latest' restart: unless-stopped ports: - '80:80' - '81:81' - '443:443' volumes: - ./data:/data - ./letsencrypt:/etc/letsencrypt "},"blog/other/gitbookEnvPrepare.html":{"url":"blog/other/gitbookEnvPrepare.html","title":"gitbook使用举例","keywords":"","body":"gitbook环境准备 # 安装nodejs, 因为gitbook根据依赖,且gitbook不再维护更新,需要node.js 10.21.0以下 # 下载并安装 https://nodejs.org/download/release/v10.12.0/ # 设置npm源 npm config set registry https://registry.npm.taobao.org # 切换到官方源 npm config set registry http://www.npmjs.org # 查看源 npm get registry # 安装命令行工具 npm install -g gitbook-cli # 会自动安装gitbook gitbook -V # 再次执行,提示这个版本说明安装成功了 # 因为已经停止维护了,最新的版本就是这个了. gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 创建项目 # 创建文件夹, 这个就是gitbook的项目目录 mkdir book # 初始化 cd book gitbook init # 打包 默认打包到_book gitbook build # 启动服务, 默认_book gitbook serve # 访问默认地址 http://localhost:4000/ 目录说明 # 项目创建,生成SUMMARY.md和README.md SUMMARY.md 项目 README.md 首页 book.js 其实官方使用的是 book.json,我们使用npm管理,module.exports输出一个json .bookignore 构建时忽略的文件,防止_book文件太大,多余的不进行打包 插件安装 npm install gitbook-plugin-search-pro npm install gitbook-plugin-chapter-fold npm install gitbook-plugin-sitemap npm install gitbook-plugin-theme-lou npm install gitbook-plugin-back-to-top-button npm install gitbook-plugin-code npm install gitbook-plugin-prism 文件内容 book.js module.exports = { \"title\": \"我的文档\", \"author\": \"tianv5\", \"description\": \"文档\", \"keywords\": \"学习,笔记,编程,代码,博客,文章,github\", \"introduction\": { \"path\": \"README.md\", \"title\": \"前言\", }, \"variables\": { \"themeColor\": \"#3884ff\", \"themeLou\": { // 顶部导航栏配置 \"nav\": [ { \"target\": \"_blank\", // 跳转方式: 打开新页面 \"url\": \"https://www.baidu.com\", // 跳转页面 \"name\": \"百度\" // 导航名称 } ] } }, \"plugins\": [ \"-highlight\", \"-lunr\", \"-search\", \"-sharing\", \"-livereload\", \"search-pro\", \"chapter-fold\", \"sitemap\", \"theme-lou\", \"back-to-top-button\", \"code\", \"prism\" ], \"pluginsConfig\": { \"chapter-fold\": {}, \"theme-lou\": { \"color\": \"#5F9EA0\", // 主题色 \"favicon\": \"static/favicon.ico\", // favicon图标 \"logo\": \"static/logo.png\", // 顶部左侧图标 \"forbidCopy\": false, // 页面是否禁止复制 \"search-placeholder\": \"全局搜索\", // 搜索框默认文本 \"book-summary-title\": \"导航\", // 目录标题 \"book-anchor-title\": \"本章目录标题\", // 本章目录标题 \"hide-elements\": [\".summary .gitbook-link\"], \"imgStyle\": { \"isCenter\": true, // 是否居中(默认为true) \"isBox\": false, // 是否有边框(默认为true) \"otherStyle\": 'max-width: 80%;', // 图片其他自定义CSS样式 } }, \"sitemap\": { \"hostname\": \"https://tianv5.github.io/docs\" }, \"prism\": { \"css\": [ \"prismjs/themes/prism-okaidia.css\" ], \"lang\": { \"flow\": \"typescript\" } } }, \"pdf\": { \"toc\": true, \"pageNumbers\": true, \"fontSize\": 12, \"paperSize\": \"a4\", \"margin\": { \"right\": 62, \"left\": 62, \"top\": 36, \"bottom\": 36 } } } ; .gitignore .idea _book node_modules .bookignore package.json package-lock.json .bookignore .gitignore Summary.md 目录和文件不要有空格等特殊符号 不然目录跳转容易有问题 # Summary ## 简介 * [前言](README.md) ## 中间件 * [ElasticSearch](blog/elk/elk.md) * [index,store,copy_to,enable的概念](blog/elk/mapping01.md) ## 其他 * [gitbook教程](blog/gitbook教程/gitbook教程.md) * [插件的使用](blog/gitbook教程/插件的使用.md) "},"blog/other/GitHubActions.html":{"url":"blog/other/GitHubActions.html","title":"github Actions自动构建","keywords":"","body":"GitHub Actions CI/CD的工具 当我们提交代码的时候,可以触发流水线. 我们的目的是自动构建 gitbook build,并将编译好的代码静态页面提交到个人仓库中, 并自动更新到github pages. 配置secrets 创建token 在个人中心配置需要的token 根据需求填写对应的信息、重点关注workflow权限 填写完成创建token 复制对应的token字符串 将token字符串填写到项目token中 填写copy的token字符串提交，即可创建完成 注意最后一步的token name，就是workflow中的使用名称CI脚本 工作流程在 .github/workflows 目录中定义,此目录下所有yml文件都会被执行. .github/workflows/ci.yml 如我们的文件编辑如下 当我们推送代码,触发Actions时 切换到主分支main 安装node.js 因为我们的gitbook依赖 安装gitbook 安装gitbook服务需要的各种插件 执行git build,生成_book目录 将_book目录内容,推送到仓库的gh-pages分支 做完以上步骤,github pages也会触发一个流水线,将gh-pages内容更新. name: auto-generate-gitbook on: #在main分支上进行push时触发 push: branches: - main jobs: main-to-gh-pages: runs-on: ubuntu-latest steps: - name: checkout main uses: actions/checkout@v2 with: ref: main - name: install nodejs uses: actions/setup-node@v1 - name: configue gitbook run: | npm install -g gitbook-cli npm install gitbook-plugin-search-pro npm install gitbook-plugin-chapter-fold npm install gitbook-plugin-sitemap npm install gitbook-plugin-theme-lou npm install gitbook-plugin-back-to-top-button npm install gitbook-plugin-code npm install gitbook-plugin-prism - name: generate _book folder run: | gitbook build cp SUMMARY.md _book - name: push _book to branch gh-pages env: TOKEN: ${{ secrets.TOKEN }} REF: github.com/${{github.repository}} MYEMAIL: xxxxxxxxx@qq.com # ！！！ 记得修改为自己github设置的邮箱 MYNAME: ${{github.repository_owner}} run: | cd _book git config --global user.email \"${MYEMAIL}\" git config --global user.name \"${MYNAME}\" git init git remote add origin https://${REF} git add . git commit -m \"Updated By Github Actions With Build ${{github.run_number}} of ${{github.workflow}} For Github Pages\" git branch -M main git push --force --quiet \"https://${TOKEN}@${REF}\" main:gh-pages "},"blog/other/git常用命令.html":{"url":"blog/other/git常用命令.html","title":"git常用命令","keywords":"","body":"git常用命令 git中文乱码git config --global core.quotepath false reset常用 ```text git reset [--soft | --mixed | --hard] [] --soft：会保留更改内容，暂存区和 HEAD 指向的当前分支的引用都不会改变。 --mixed：是默认选项，会保留更改内容，但是暂存区的内容会被清空到工作目录。 --hard：不保留任何更改，包括工作目录和暂存区的内容都会回滚到指定的 状态。 - tag 1. `git tag `就可以打一个新标签: 2. 可以用命令`git tag`查看所有标签: 3. 默认标签是打在最新提交的commit上的。把标签打在特定版本上， `git tag v0.9 471fd27`。 4. 命令`git tag`查看标签：注意，标签不是按时间顺序列出，而是按字母排序的。 5. 可以用`git show `查看标签信息： 6. 上面我们打的tag是轻量级的也就是一般的tag没有注释，下面看看有注释的标签 - 创建带有说明的标签，用-a指定标签名，-m指定说明文字： `git tag -a v0.1 -m \"version 0.1 released push url\" d5a65e9` 7. 把本地仓库分支tag推送到远程服务器 默认情况下，git push并不会把tag标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。 `git push origin [tagname]` 8. push所有tag，命令格式为： ```text git push [origin] --tags git push --tags 或 git push origin --tags 当远程有多个服务的时候远程服务名称是必须的，而如果远程只有一个远程服务则远程服务名称可以省略。 通过标签恢复代码 查看标签的详情，找出打标签的那次提交的commit id 版本回退（将主干分支回退到某个版本） git reset --hard d5a65e 注意把d5a65e换成你的commid id。回退完毕,其实就是把head指针指向了制定版本位置 从当前tag拉分支 当我们一次迭代上线前会对master分支打一个tag,这个tag作为回滚备份，然后将新需求分支合并到master在用master代码上线，如果最新master出现问题则我们可以从最新tag拉取分支。 (1) 切换到具体tag git checkout tag_name (2) 从tag拉取新分支 git branch （3）从tag拉取新分支 git checkout -b branch_name tag_name 切换到具体tag后使用2、3两种方式都能从当前tag拉取新分支，然后基于该分支进行bugfix,修复后可以再次合并到master; 查看当前分支提交的log日志 git log 可以看到只有第一次的提交记录了，因为这个时候版本回退了git log是查不到第三次提交记录的，怎么办呢，怎么才能回去呢？ 我们用下面这个命令： git reflog git reflog 相比git log能查询更多的日志信息，两个的具体区别之后再详细学习，反正使用git reflog 能查询到所有的日志commit id即使是删除的。 git log和git reflog 的区别 git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录 "},"blog/other/common_tool_re.html":{"url":"blog/other/common_tool_re.html","title":"常用的正则举例","keywords":"","body":"正则常用参考 一、校验数字的表达式 1. 数字：^[0-9]*$ 2. n位的数字：^\\d{n}$ 3. 至少n位的数字：^\\d{n,}$ 4. m-n位的数字：^\\d{m,n}$ 5. 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 12. 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ 13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1. 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3. 长度为3-20的所有字符：^.{3,20}$ 4. 由26个英文字母组成的字符串：^[A-Za-z]+$ 5. 由26个大写英文字母组成的字符串：^[A-Z]+$ 6. 由26个小写英文字母组成的字符串：^[a-z]+$ 7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11. 可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$ 4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5. 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6. 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7. 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 12. 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 16. 1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ 17. 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 18. 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 19. 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 20. 5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$ 21. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 22. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 24. 备注：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 25. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 26. 中文字符的正则表达式：[\\u4e00-\\u9fa5] 27. 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 28. 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 29. HTML标记的正则表达式：]*>.*?| (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 30. 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 31. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 32. 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 33. IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) 34. IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) "},"blog/python/singleton.html":{"url":"blog/python/singleton.html","title":"我看到的一个比较好的单例实现","keywords":"","body":"我看到的一个比较好的单例实现 前言 单例模式很常见，实现有很多地方值得优化，具体的优化历程，此处不多做赘述。 谨在此记录一个本人认为完善的，单例实现。具体实现思路使用Python实现。 其他语言也可以借鉴思路。 python代码举例 import time import threading class Singleton(object): _instance_lock = threading.Lock() def __init__(self): time.sleep(1) @classmethod def instance(cls, *args, **kwargs): if not hasattr(Singleton, \"_instance\"): with Singleton._instance_lock: if not hasattr(Singleton, \"_instance\"): Singleton._instance = Singleton(*args, **kwargs) return Singleton._instance "},"blog/other/questions.html":{"url":"blog/other/questions.html","title":"常见问题集锦","keywords":"","body":"questions chatGML 问题模板 代码截图识别 请将图片中的代码，识别输出(包含注释)。请注意，识别的文本是python代码，请输出格式化后的python代码。 请将图片中的文本，识别输出（包含表头）。请注意，识别的文本是csv格式的文本，请按照`csv`格式输出。 python, sqlmap报错 AttributeError: module ‘collections‘ has no attribute ‘Callable‘ 进入python安装目录 如我的在e盘下修改py3k_compat.py这个文件E:\\python\\lib\\site-packages\\pyreadline\\py3k_compat.py 在第8行把 return isinstance(x, collections.Callable)改为 return isinstance(x, collections.abc.Callable)即可正常使用 问题描述 这个脚本只能用bash执行，用sh执行报错 现在有个场景是必须用sh来执行，不能用bash，要怎么改脚本 解决方法 ushield_list=`echo \"163c0625\" \"8102155b\" \"8005155b\" \"8006155b\" \"04011780\" \"04101780\" \"10041ea8\" \"0705096e\" ` for i in $ushield_list do echo $i done 计算机常用术语 Windows WSL 卸载 ubuntu ubuntu系统如何修改hostname ```text 需要编辑/etc/hostname文件。使用文本编辑器以超级用户权限打开此文件： sudo vi /etc/hostname 删除旧的主机名，并输入新的主机名。保存并关闭文件。 同样，您还需要编辑/etc/hosts文件，以确保该文件中的主机名与您刚刚设置的新主机名相匹配。同样使用文本编辑器以超级用户权限打开此文件： sudo vi /etc/hosts 找到包含127.0.1.1的行，并更改该行的主机名部分以匹配新的主机名。保存并关闭文件。 重启计算机或注销会话以使更改生效： sudo reboot 或者如果您只是想测试更改而不立即重启： hostnamectl 这将显示当前的主机名设置，包括您刚才所做的更改。 ``` 问题描述 ctr镜像导入报错ctr: content digest sha256:xxxxxx not found 解决方案 现象： 直接导入j镜像可能会出现类似于 ctr: content digest sha256:xxxxxx not found 解决办法： 拉取镜像、导出镜像时，加上--platform "},"blog/other/mysql_import_export.html":{"url":"blog/other/mysql_import_export.html","title":"mysql的一些基础","keywords":"","body":"mysql的一些操作 加速导入 # 关闭日志,0是关闭，1是开启 set sql_log_bin=OFF; select @@sql_log_bin; # 关闭autocommit自动提交模式 0是关闭 1 是开启（默认） set autocommit=0; select @@autocommit; commit;和rollback; # 还有因为autocommit是session级别的，我们重新登录，或者重新打开navicat中的查询页面，都需要单独设置。 就是说 在查询页面中执行插入语句 或者 在命令行导入时的场景，要记得手动设置提交。 3.1 通过以下语句查看下当前packet的大小限制，下图显示笔者mysql默认支持64Mb大小的packet传输。 show variables like '%max_allowed_packet%'; 或者 select @@max_allowed_packet; 3.2 MySQL 8.0单个packet可以允许的最大值是1GB，最小为1K。这里的最大 意味着您即使设置了2Gb，实际上也只能传输1Gb内的packet。 # 数据换算：1073741824 = 1024 * 1024 * 1024 = 1Gb set global max_allowed_packet = 1073741824; 3.3 然后查询下配置是否已生效, 切记 不要去重启mysql服务，重新打开navicat查询界面语句 查询下即可。 因为目前未将配置写入my.ini文件，重启mysql将导致配置失效，回退到原64Mb大小。 select @@max_allowed_packet; 常见操作 登录成功后执行如下命令 ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!'; 或者 set password for'root'@'localhost'=password('MyNewPass4!'); 关于密码设置 如果只是修改为一个简单的密码，会报以下错误： mysql> ALTER USERUSER() IDENTIFIED BY '12345678'; ERROR 1819 (HY000): Your password does not satisfy thecurrent policy requirements 这个其实与validate_password_policy的值有关。 validate_password_policy有以下取值： Policy TestsPerformed 0 or LOW Length 1 or MEDIUM Length;numeric, lowercase/uppercase, and special characters 2 or STRONG Length;numeric, lowercase/uppercase, and special characters; dictionary file 默认是1，即MEDIUM，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。 有时候，只是为了自己测试，不想密码设置得那么复杂，譬如说，我只想设置root的密码为123456。 必须修改两个全局参数： 首先，修改validate_password_policy参数的值 set global validate_password_policy=0; Query OK, 0 rows affected (0.00 sec) 这样，判断密码的标准就基于密码的长度了。这个由validate_password_length参数来决定。 导入导出 1. 导出数据和表结构： mysqldump -u用户名 -p密码数据库名 > 数据库名.sql #/usr/local/mysql/bin/ mysqldump -uroot -p abc > abc.sql 敲回车后会提示输入密码 2. 只导出表结构 mysqldump -u用户名 -p密码 -d 数据库名 > 数据库名.sql #/usr/local/mysql/bin/ mysqldump -uroot -p -d abc > abc.sql 注：/usr/local/mysql/bin/ ---> mysql的data目录 3. 导入数据库 1、首先建空数据库 create database abc; 2、导入数据库 方法一： （1）选择数据库 use abc; （2）设置数据库编码 set names utf8; （3）导入数据（注意sql文件的路径） source /home/abc/abc.sql; 方法二： mysql -u用户名 -p密码数据库名 常用设置 1、 设置表格字符集 举例如下： CREATE TABLE `Customers` ( `cust_id` char(10) NOT NULL, `cust_name` char(50) NOT NULL, `cust_address` char(50) DEFAULT NULL, `cust_city` char(50) DEFAULT NULL, `cust_state` char(5) DEFAULT NULL, `cust_zip` char(10) DEFAULT NULL, `cust_country` char(50) DEFAULT NULL, `cust_contact` char(50) DEFAULT NULL, `cust_email` char(255) DEFAULT NULL, PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; "},"blog/other/机试题目.html":{"url":"blog/other/机试题目.html","title":"一些题目整理","keywords":"","body":"机试题目 API集群负载统计 时间限制:1s 空间限制:256MB 限定语言:不限 题目描述 某个产品的RESTfulAPI集合部署在服务器集群的多个节点上， 近期对客户端访问日志进行了采集，需要统计各个API的访问频次根据热点信息在服务器节点之间做负载均衡， 现在需要实现热点信息统计查询功能。RESTfulAPI的由多个层级构成， 层级之间使用/连接，如/A/B/C/D这个地址，A属于第一级，B属于第二级，C属于第三级，D属于第四级。 现在负载均衡模块需要知道给定层级的上某个各字出现的频次，未出现过用0次表示，实现这个功能。 输入描述第一行为N，表示访问历史日志的条数，0demo anwser import sys input_strs = list() for line in sys.stdin: input_str = line.strip() if input_str: input_strs.append(input_str) n = int(input_strs[0]) urls = input_strs[1: 1+n] level_key: str = input_strs[1+n] level, key = level_key.split() level = int(level) source = dict() for url in urls: names = url.split('/') for index in range(len(names)): name = names[index] if name: if index in source: if name in source[index]: source[index][name] += 1 else: source[index][name] = 1 else: source[index] = dict() source[index][name] = 1 if level not in source: print(0) elif key not in source[level]: print(0) else: print(source[level][key]) ======================================================= CPU算力分配 ``` ### question ### demo ### anwser ```python import sys def main(): input_strs = list() for line in sys.stdin: input_str = line.strip() if input_str: input_strs.append(input_str) A_cpu_cnt, B_cpu_cnt = [int(i) for i in input_strs[0].split()] A_cpu_list = [int(i) for i in input_strs[1].split()] B_cpu_list = [int(i) for i in input_strs[2].split()] A_cpu_list.sort() B_cpu_list.sort() A_sum = sum(A_cpu_list) B_sum = sum(B_cpu_list) for a in A_cpu_list: for b in B_cpu_list: if A_sum + b -a == B_sum + a - b: print(a, b) return main() ======================================================= 5G网络建设 ``` ### question 现需要在某城市建设5G网络建设，已经选取N个地点设置5G基站，编号固定为1到N，接下来需要哥哥基站之间使用光纤进行连接， 以确保基站能互联互通，不同基站之间架设光纤的成本各不相同，且有些节点之间已经存在光纤连接。 请你设计算法，计算出能联通这些基站的最小成本是多少。 注意：基站的联通具有传递性，入基站A与基站B架设了光纤，基站B与基站C也架设了光纤， 则基站A与基站C视为可以互相联通。 输入描述： 第一行输入标识基站的个数，其中0 从第三行开始连续输入M行数据，格式为 X Y Z P， 其中X Y 表示基站的编号， 0 输出描述： 如果给定条件，可以建设成功互联互通的5G网络, 则输出最小的建设成本 如果给定条件，无法建设成功互联互通的5G网络，则输出-1 ### demo ### anwser ```python class Edge: # 定义边的类 def __init__(self, u, v, cost, pre): self.u = u # 基站u self.v = v # 基站v self.cost = cost # 架设光纤的成本 self.pre = pre # 是否已存在光纤连接 def find(x): # 并查集查找函数，用于查找x所在的集合 if parent[x] != x: # 如果x不是自己的父节点，那么就让x的父节点为x的父节点的父节点（路径压缩） parent[x] = find(parent[x]) return parent[x] # 返回x的父节点 def union(x, y): # 并查集合并函数，用于合并x和y所在的集合 rootX = find(x) # 找到x的根节点 rootY = find(y) # 找到y的根节点 if rootX != rootY: # 如果x和y的根节点不同，那么就将x的根节点的父节点设为y的根节点 parent[rootX] = rootY if __name__ == \"__main__\": N = int(input()) # 输入基站的个数 M = int(input()) # 输入具备光纤直连条件的基站对的数目 parent = [i for i in range(N + 1)] # 初始化并查集数组，初始时每个节点的父节点就是自己 edges = [] # 存储所有的边 for _ in range(M): X, Y, Z, P = map(int, input().split()) # 输入基站X, Y, 架设光纤的成本Z, 是否已存在光纤连接P edges.append(Edge(X, Y, Z, P)) # 添加边 if P == 1: # 如果已存在光纤连接，那么就将X和Y合并 union(X, Y) # 将所有的边按照成本从小到大排序 edges.sort(key=lambda edge: edge.cost) cost = 0 # 总的成本 for edge in edges: # 如果边的两个端点不在同一个集合中，那么就将这条边添加到最小生成树中 if find(edge.u) != find(edge.v): cost += edge.cost # 累加成本 union(edge.u, edge.v) # 合并边的两个端点所在的集合 for i in range(2, N + 1): # 检查所有的基站是否都在同一个集合中 if find(i) != find(1): # 如果有基站不在同一个集合中，那么就输出-1并结束程序 print(-1) break else: # 输出总的成本 print(cost) ======================================================= title ``` ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `=======================================================` ## title ### question ### demo ### anwser `` =======================================================` "},"blog/gusheshanrenshuo/fun.html":{"url":"blog/gusheshanrenshuo/fun.html","title":"姑射山人说","keywords":"","body":"姑射山人说 关于疫情 关于俄乌战争 关于唐代服务 "},"blog/devops/常用命令整理.html":{"url":"blog/devops/常用命令整理.html","title":"devops","keywords":"","body":"常用命令整理 ubuntu快速安装docker apt -y install apt-transport-https ca-certificates curl gnupg-agent software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" apt update apt -y install docker-ce docker-ce-cli containerd.io systemctl status docker apt-mark hold docker-ce docker container run hello-world apt -y install docker-compose apt-mark hold docker-compose docker version docker-compose version ssh-keygen -t rsa -P '' docker修改国内安装源 以下是一些常用的国内Docker镜像源： DaoCloud加速器（https://www.daocloud.io/mirror） 网易云镜像（https://hub-mirror.c.163.com） 阿里云镜像（https://cr.console.aliyun.com/） 使用这些镜像源，可以通过修改Docker的配置文件来替换默认的镜像源。具体操作如下： 打开Docker配置文件（通常位于/etc/docker/daemon.json或者~/.docker/daemon.json）。 如果文件不存在，可以创建一个新的文件。 在配置文件中添加以下内容，替换为对应的镜像源地址：{ \"registry-mirrors\": [\"镜像源地址\"] } 保存配置文件，并重启Docker服务。 修改完配置文件并重启Docker服务后，Docker将会使用国内的镜像源来下载和部署镜像，加快速度和稳定性。81 LANG=zh_CN.UTF-8 82 LANGUAGE=zh_US: { \"insecure-registries\" : [\"192.168.1.11:80\"], \"registry-mirrors\": [\"https://cr.console.aliyun.com/\"] } docker部署gitlab 创建docker-compose.yml version: '3.1' services: gitlab: image: 'gitlab/gitlab-ce:latest' container_name: gitlab restart: always environment: GITLAB_OMNIBUS_CONFIG: | external_url 'http://192.168.1.11:8998' gitlab_rails['gitlab_shell_ssh_port'] = 2224 ports: - '8998:8998' - '2224:22' volumes: - ./data:/var/opt/gitlab - ./logs:/var/log/gitlab - ./config:/etc/gitlab 可能用到的命令 docker-compose up -d docker-compose logs -f docker exec -it gitlab bash docker部署jenkins 创建docker-compose.yml version: \"3.1\" services: jenkins: container_name: jenkins image: jenkins/jenkins:lts user: root ports: - 8888:8080 - 50000:50000 restart: \"always\" volumes: - ./data/:/var/jenkins_home/ jenkins修改安装源 修改 data/hudson.model.UpdateCenter.xml default https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 替换国内： sed -i 's/https:\\/\\/updates.jenkins.io\\/download/http:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g' data/updates/default.json sed -i 's/https:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g' data/updates/default.json 安装sonarqube docker pull postgres docker pull sonarqube:9.9-community mkdir sonarqube_docker cd sonarqube_docker vim docker-compose.yml docker-compose.yml 如下： version: \"3.1\" services: db: image: postgres container_name: db ports: - 5432:5432 networks: - sonarnet environment: POSTGRES_USER: sonar POSTGRES_PASSWORD: sonar sonarqube: image: sonarqube:9.9-community container_name: sonarqube depends_on: - db ports: - 9000:9000 networks: - sonarnet environment: SONAR_JDBC_URL: jdbc:postgresql://db:5432/sonar SONAR_JDBC_USERNAME: sonar SONAR_JDBC_PASSWORD: sonar networks: sonarnet: driver: bridge 修改系统配置 vim /etc/sysctl.conf vm.max_map_count = 262144 重启使生效，sysctl -p 查看日志 docker-compose logs -f sonar-scanner 集成到jenkins 下载sonar-scanner https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip squ_a6079b4fa22eaf3e9579e7b0f297221bf7beb8e5 /root/docker-jenkins/data/sonar-scanner/bin/sonar-scanner -Dsonar.source=./ -Dsonar.projectname=demo1 -Dsonar.login=squ_a6079b4fa22eaf3e9579e7b0f297221bf7beb8e5 -Dsonar.projectKey=demo1 jenkins安装配置插件 /var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.source=./ -Dsonar.projectname=demo1 -Dsonar.login=squ_a6079b4fa22eaf3e9579e7b0f297221bf7beb8e5 -Dsonar.projectKey=demo1 rm -rf docker-jenkins/data/workspace/testjenkins/src/.scannerwork/ cd /var/jenkins_home/workspace/ harbor安装 下载 Releases · goharbor/harbor (github.com) harbor地址/项目名/镜像名:版本 docker配置 docker创建 /etc/docker/daemon.json { \"insecure-registries\" : [\"192.168.1.11:80\"] } 重启docker Docker 删除 none docker images | grep none | awk '{print $3}' | xargs docker rmi docker容器jenkins内使用宿主机docker /var/run/docker.sock 映射 chown root:root docker.sock chmod o+rw docker.sock version: \"3.1\" services: jenkins: container_name: jenkins image: jenkins/jenkins:lts user: root ports: - 8888:8080 - 50000:50000 restart: \"always\" volumes: - ./data/:/var/jenkins_home/ - /var/run/docker.sock:/var/run/docker.sock - /usr/bin/docker:/usr/bin/docker - /etc/docker/daemon.json:/etc/docker/daemon.json 一个部署脚本 harbor_addr=$1 harbor_repo=$2 project=$3 version=$4 container_port=$5 host_port=$6 harbor_user=$7 harbor_password=$8 image_name=$harbor_addr/$harbor_repo/$project img=$harbor_addr/$harbor_repo/$project:$version echo $image_name for container_id in `docker ps -a |grep $project |awk -F' ' '{print $1}' ` do echo $container_id docker stop $container_id docker rm $container_id done for tag in `docker images | grep $image_name | awk -F ' ' '{print $2}' ` do if [ $tag = $version ] then docker rmi -f $img fi done docker login -u $harbor_user -p $harbor_password $harbor_addr docker pull $img docker run -d -p $host_port:$container_port --name $project $img docker ps -a |grep $project echo SUCCESS git checkout $tag if [ -e \"src.tar.gz\" ] then rm -rf src.tar.gz fi tar -zvcf src.tar.gz src git tag -a 'v5.0.0' -m \"单机harbor第三个版本\" git push origin v5.0.0 ubuntu 绑定ip vi /etc/network/interfaces auto eth0 iface eth0 inet static address 192.168.1.50 netmask 255.255.255.0 gateway 192.168.1.1 "},"blog/other/k8s.html":{"url":"blog/other/k8s.html","title":"K8S教程","keywords":"","body":"k8s 11.k8s-tutorials Star 1.4kFork 113 Watch 13 免费的 Kubernetes 教程。K8s 作为云原生时代的必备技能之一，多少得会一些。该教程侧重于实战引导，用 Go 写的项目作为演示对象，从最基础的容器定义开始，逐一讲述 pod、deployment、service、ingress 等资源，直到用 helm 打包部署一套完整服务。 "},"blog/devops/k8s笔记.html":{"url":"blog/devops/k8s笔记.html","title":"K8S笔记","keywords":"","body":"k8s笔记 windows 修改host 文件路径： C:\\Windows\\System32\\drivers\\etc deployment kubectl create deployment deploy-nginx--image=docker.io/library/nginx:latest -n test kubectl get deploy -n test kubectl delete deploy deploy-nginx -n test apiVersion: apps/v1 kind: Deployment metadata: namespace: test name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 service kubectl expose deployment nginx-deployment --port=8888 --target-port=80 -n test kubectl get service -n test kubectl delete service nginx-deployment -n test kubectl expose deployment nginx-deployment \\ --port=8888 --target-port=80 -n test \\--type=NodePort 同一个yml部署 kubectl rollout restart deployment pipline -n test apiVersion: apps/v1 kind: Deployment metadata: namespace: test name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: namespace: test name: nginx-deployment labels: app: nginx spec: selector: app: nginx ports: - port: 8888 targetPort: 80 type: NodePort --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: namespace: test name: nginx-ingress spec: ingressClassName: ingress rules: - host: k8s.learn.wcx http: paths: - path: / pathType: Prefix backend: service: name: nginx-deployment port: number: 8888 apiVersion: apps/v1 kind: Deployment metadata: namespace: test name: nginx-deployment labels: app: mydemo spec: replicas: 3 selector: matchLabels: app: mydemo template: metadata: labels: app: mydemo spec: containers: - name: mydemo image: 192.168.1.11:80/repo/mydemo:v5.0.0 ports: - containerPort: 8000 --- apiVersion: v1 kind: Service metadata: namespace: test name: nginx-deployment labels: app: mydemo spec: selector: app: mydemo ports: - port: 8888 targetPort: 8000 type: NodePort --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: namespace: test name: nginx-ingress spec: ingressClassName: ingress rules: - host: k8s.learn.wcx http: paths: - path: / pathType: Prefix backend: service: name: nginx-deployment port: number: 8888 k8s大体架构 docker run -d \\ --restart=unless-stopped \\ --name=kuboard \\ -p 80:80/tcp \\ -p 10081:10081/tcp \\ -e KUBOARD_ENDPOINT=\"http://192.168.1.34:80\" \\ -e KUBOARD_AGENT_SERVER_TCP_PORT=\"10081\" \\ -v /root/kuboard-data:/data \\ eipwork/kuboard:v3 apiVersion: v1 kind: Namespace metadata: name: test apiVersion: v1 kind: Pod metadata: name: nginx-yml namespace: test spec: containers: - image: nginx:latest name: nginx-yml apiVersion: v1 kind: Pod metadata: name: nginx-yml namespace: test spec: containers: - image: nginx:latest name: nginx-yml imagePullPolicy: IfNotPresent 国内containered配置 disabled_plugins = [] imports = [] oom_score = 0 plugin_dir = \"\" required_plugins = [] root = \"/var/lib/containerd\" # 容器存放路径，确保可用空间充足 state = \"/run/containerd\" version = 2 [cgroup] path = \"\" [debug] address = \"\" format = \"\" gid = 0 level = \"\" uid = 0 [grpc] address = \"/run/containerd/containerd.sock\" gid = 0 max_recv_message_size = 16777216 max_send_message_size = 16777216 tcp_address = \"\" tcp_tls_cert = \"\" tcp_tls_key = \"\" uid = 0 [metrics] address = \"\" grpc_histogram = false [plugins] [plugins.\"io.containerd.gc.v1.scheduler\"] deletion_threshold = 0 mutation_threshold = 100 pause_threshold = 0.02 schedule_delay = \"0s\" startup_delay = \"100ms\" [plugins.\"io.containerd.grpc.v1.cri\"] disable_apparmor = false disable_cgroup = false disable_hugetlb_controller = true disable_proc_mount = false disable_tcp_service = true enable_selinux = false enable_tls_streaming = false ignore_image_defined_volumes = false max_concurrent_downloads = 3 max_container_log_line_size = 16384 netns_mounts_under_state_dir = false restrict_oom_score_adj = false sandbox_image = \"registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6\" selinux_category_range = 1024 stats_collect_period = 10 stream_idle_timeout = \"4h0m0s\" stream_server_address = \"127.0.0.1\" stream_server_port = \"0\" systemd_cgroup = false tolerate_missing_hugetlb_controller = true unset_seccomp_profile = \"\" [plugins.\"io.containerd.grpc.v1.cri\".cni] bin_dir = \"/opt/cni/bin\" conf_dir = \"/etc/cni/net.d\" conf_template = \"/etc/cni/net.d/cni-default.conf\" max_conf_num = 1 [plugins.\"io.containerd.grpc.v1.cri\".containerd] default_runtime_name = \"runc\" disable_snapshot_annotations = true discard_unpacked_layers = false no_pivot = false snapshotter = \"overlayfs\" [plugins.\"io.containerd.grpc.v1.cri\".containerd.default_runtime] base_runtime_spec = \"\" container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = \"\" runtime_root = \"\" runtime_type = \"\" [plugins.\"io.containerd.grpc.v1.cri\".containerd.default_runtime.options] [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes] [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc] base_runtime_spec = \"\" container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = \"\" runtime_root = \"\" runtime_type = \"io.containerd.runc.v2\" [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc.options] BinaryName = \"\" CriuImagePath = \"\" CriuPath = \"\" CriuWorkPath = \"\" IoGid = 0 IoUid = 0 NoNewKeyring = false NoPivotRoot = false Root = \"\" ShimCgroup = \"\" SystemdCgroup = true [plugins.\"io.containerd.grpc.v1.cri\".containerd.untrusted_workload_runtime] base_runtime_spec = \"\" container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = \"\" runtime_root = \"\" runtime_type = \"\" [plugins.\"io.containerd.grpc.v1.cri\".containerd.untrusted_workload_runtime.options] [plugins.\"io.containerd.grpc.v1.cri\".image_decryption] key_model = \"node\" [plugins.\"io.containerd.grpc.v1.cri\".registry] config_path = \"\" [plugins.\"io.containerd.grpc.v1.cri\".registry.auths] [plugins.\"io.containerd.grpc.v1.cri\".registry.configs] [plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"192.168.1.11:80\".auth] username = \"admin\" password = \"Harbor12345\" [plugins.\"io.containerd.grpc.v1.cri\".registry.headers] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"192.168.1.11:80\"] endpoint = [\"http://192.168.1.11:80\"] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"docker.io\"] endpoint = [\"https://docker.mirrors.ustc.edu.cn\", \"http://hub-mirror.c.163.com\"] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"gcr.io\"] endpoint = [\"https://gcr.mirrors.ustc.edu.cn\"] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"k8s.gcr.io\"] endpoint = [\"https://gcr.mirrors.ustc.edu.cn/google-containers/\"] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"quay.io\"] endpoint = [\"https://quay.mirrors.ustc.edu.cn\"] [plugins.\"io.containerd.grpc.v1.cri\".x509_key_pair_streaming] tls_cert_file = \"\" tls_key_file = \"\" [plugins.\"io.containerd.internal.v1.opt\"] path = \"/opt/containerd\" [plugins.\"io.containerd.internal.v1.restart\"] interval = \"10s\" [plugins.\"io.containerd.metadata.v1.bolt\"] content_sharing_policy = \"shared\" [plugins.\"io.containerd.monitor.v1.cgroups\"] no_prometheus = false [plugins.\"io.containerd.runtime.v1.linux\"] no_shim = false runtime = \"runc\" runtime_root = \"\" shim = \"containerd-shim\" shim_debug = false [plugins.\"io.containerd.runtime.v2.task\"] platforms = [\"linux/amd64\"] [plugins.\"io.containerd.service.v1.diff-service\"] default = [\"walking\"] [plugins.\"io.containerd.snapshotter.v1.aufs\"] root_path = \"\" [plugins.\"io.containerd.snapshotter.v1.btrfs\"] root_path = \"\" [plugins.\"io.containerd.snapshotter.v1.devmapper\"] async_remove = false base_image_size = \"\" pool_name = \"\" root_path = \"\" [plugins.\"io.containerd.snapshotter.v1.native\"] root_path = \"\" [plugins.\"io.containerd.snapshotter.v1.overlayfs\"] root_path = \"\" [plugins.\"io.containerd.snapshotter.v1.zfs\"] root_path = \"\" [proxy_plugins] [stream_processors] [stream_processors.\"io.containerd.ocicrypt.decoder.v1.tar\"] accepts = [\"application/vnd.oci.image.layer.v1.tar+encrypted\"] args = [\"--decryption-keys-path\", \"/etc/containerd/ocicrypt/keys\"] env = [\"OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf\"] path = \"ctd-decoder\" returns = \"application/vnd.oci.image.layer.v1.tar\" [stream_processors.\"io.containerd.ocicrypt.decoder.v1.tar.gzip\"] accepts = [\"application/vnd.oci.image.layer.v1.tar+gzip+encrypted\"] args = [\"--decryption-keys-path\", \"/etc/containerd/ocicrypt/keys\"] env = [\"OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf\"] path = \"ctd-decoder\" returns = \"application/vnd.oci.image.layer.v1.tar+gzip\" [timeouts] \"io.containerd.timeout.shim.cleanup\" = \"5s\" \"io.containerd.timeout.shim.load\" = \"5s\" \"io.containerd.timeout.shim.shutdown\" = \"3s\" \"io.containerd.timeout.task.state\" = \"2s\" [ttrpc] address = \"\" gid = 0 uid = 0 生成默认模块配置文件 containerd config default > /etc/containerd/config.toml [plugins.\"io.containerd.grpc.v1.cri\".registry.auths] [plugins.\"io.containerd.grpc.v1.cri\".registry.configs] [plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"192.168.1.11:80\".tls] insecure_skip_verify = false [plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"192.168.1.11:80\".auth] username = \"admin\" password = \"Harbor12345\" [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"192.168.1.11:80\"] endpoint = [\"http://192.168.1.11:80\"] ctr images pull --plain-http 192.168.1.11:80/repo/mydemo:v5.0.0 crictl pull 192.168.1.11:80/repo/mydemo:v5.0.0 k8s常用命令 集群管理常用命令kubectl apply -f namespace-test.yml kubectl create ns test kubectl delete ns test kubectl delete pod -f nginx-tomcat -n test kubectl delete pod nginx -n test kubectl delete pod nginx-tomcat -n test --force kubectl exec -it nginx -n test -- bash kubectl get namespace kubectl get nodes -o wide kubectl get ns kubectl get pods kubectl get pods -A kubectl get pods -n test kubectl logs -f nginx -n test kubectl logs -f -n test nginx-tomcat kubectl run nginx --image=nginx:latest -n test service containerd restart ssh-keygen -t rsa -P '' containered ctr images pull --plain-http 192.168.1.11:80/repo/mydemo:v5.0.0 ctr c create docker.io/library/nginx:latest nginx1 ctr c delete nginx1 ctr c ls ctr c rm nginx2 ctr --help ctr images ctr images delete docker.io/library/nginx:latest ctr images export ngx.img docker.io/library/nginx:latest ctr images export ngx.img --platform linux/amd64 docker.io/library/nginx:latest ctr images --help ctr images import --help ctr images import ngx.img ctr images ls ctr images mount docker.io/library/nginx:latest /mnt ctr images pull docker.io/library/nginx:latest ctr images pull --help ctr images pull --platform linux/amd64 docker.io/library/nginx:latest ctr run -d --net-host docker.io/library/nginx:latest nginx2 ctr run --help ctr task delete nginx1 ctr task exec --exec-id $RANDOM nginx1 /bin/bash ctr task exec --exec-id $RANDOM nginx1 /bin/sh ctr task --help ctr task kill nginx2 ctr task ls ctr task start -d nginx1 containerd 端口映射的问题？ ctr run --net-host --mount type=bind,src=/var/run/containerd/sock,dst=/var/run/containerd/sock,options=bind:rw --env CONTAINERD_ADDRESS=/var/run/containerd/sock --hostname mycontainer --runtime runc --image myimage:latest --port 8080:80 mycontainer docker "},"blog/devops/k8s编写yml.html":{"url":"blog/devops/k8s编写yml.html","title":"K8S编写yml的技巧","keywords":"","body":"k8s编写yml yml语法 字段类型 map 类型是如何确定的？ 命令 explain命令 kubectl explain pod.spec.containers help kubectl create --help dry-run 不启动，只是验证命令 kubectl create deployment web666 --image=nginx --replicas=3 -n test --dry-run=client -o yaml VSCode工具生成和编写 VSCode安装拓展： Kubernets Templates： 帮助你轻松编写、管理k8s YAML文件 YAML提供高亮和语法检查 devops 工程建设与工具化 Linux Ansible Jenkins Prometheus Git ELK 网站架构 Nginx LVS Mysql Tomcat 微服务 平台化运维 Python Go 前端开发 K8s平台 CMDB 发布系统 Docker Kubernets lstio Ceph 网络 命令介绍 kubectl scale 命令**用于修改 Deployment、ReplicaSet 或 StatefulSet 中的副本数。 语法： kubectl scale --replicas= 参数： --replicas (必填)：要设置的副本数。 ：要缩放的资源类型，可以是 Deployment、ReplicaSet 或 StatefulSet。 ：要缩放的资源的名称。 示例： 将名为 \"my-deployment\" 的 Deployment 扩展到 5 个副本： kubectl scale --replicas=5 deployment my-deployment 将名为 \"my-replicaset\" 的 ReplicaSet 缩减到 2 个副本： kubectl scale --replicas=2 replicaset my-replicaset 将名为 \"my-statefulset\" 的 StatefulSet 扩展到 4 个副本： kubectl scale --replicas=4 statefulset my-statefulset 注意： 使用 kubectl scale 命令时，当前副本数不会被立即更改。Kubernetes 将创建一个滚动更新操作，该操作将逐步将副本数更改为指定的值。 在缩减副本数时，请确保剩余的副本具有足够的容量来处理工作负载。 kubectl scale 命令还可以用于设置资源请求和限制，但这已弃用，应使用 kubectl set resources 命令。 "}}